{
    "version": 1, 
    "interactions": [
        {
            "response": {
                "headers": {
                    "cache-control": [
                        "no-store"
                    ], 
                    "set-cookie": [
                        "phsid=A%2F6ypywsajmaqsclzrydncbnegfczzct2m5c4wovqw; expires=Thu, 14-Sep-2023 04:15:56 GMT; Max-Age=157680000; path=/; domain=phab.mercurial-scm.org; secure; httponly"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "date": [
                        "Sat, 15 Sep 2018 04:15:56 GMT"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":[{\"id\":\"4480\",\"phid\":\"PHID-DREV-gsa7dkuimmam7nafw7h3\",\"title\":\"exchangev2: start to implement pull with wire protocol v2\",\"uri\":\"https:\\/\\/phab.mercurial-scm.org\\/D4480\",\"dateCreated\":\"1536164431\",\"dateModified\":\"1536981352\",\"authorPHID\":\"PHID-USER-p54bpwbifxx7sbgpx47d\",\"status\":\"3\",\"statusName\":\"Closed\",\"properties\":{\"wasAcceptedBeforeClose\":false},\"branch\":null,\"summary\":\"Wire protocol version 2 will take a substantially different\\napproach to exchange than version 1 (at least as far as pulling\\nis concerned).\\n\\nThis commit establishes a new exchangev2 module for holding\\ncode related to exchange using wire protocol v2. I could have\\nadded things to the existing exchange module. But it is already\\nquite big. And doing things inline isn't in question because\\nthe existing code is already littered with conditional code\\nfor various states of support for the existing wire protocol\\nas it evolved over 10+ years. A new module gives us a chance\\nto make a clean break.\\n\\nThis approach does mean we'll end up writing some duplicate\\ncode. And there's a significant chance we'll miss functionality\\nas code is ported. The plan is to eventually add #testcase's\\nto existing tests so the new wire protocol is tested side-by-side\\nwith the existing one. This will hopefully tease out any\\nfeatures that weren't ported properly. But before we get there,\\nwe need to build up support for the new exchange methods.\\n\\nOur journey towards implementing a new exchange begins with pulling.\\nAnd pulling begins with discovery.\\n\\nThe discovery code added to exchangev2 is heavily drawn from\\nthe following functions:\\n\\n* exchange._pulldiscoverychangegroup\\n* discovery.findcommonincoming\\n\\nFor now, we build on top of existing discovery mechanisms. The\\nnew wire protocol should be capable of doing things more efficiently.\\nBut I'd rather defer on this problem.\\n\\nTo foster the transition, we invent a fake capability on the HTTPv2\\npeer and have the main pull code in exchange.py call into exchangev2\\nwhen the new wire protocol is being used.\",\"testPlan\":\"\",\"lineCount\":\"145\",\"activeDiffPHID\":\"PHID-DIFF-kg2rt6kiekgo5rgyeu5n\",\"diffs\":[\"11058\",\"10961\",\"10793\"],\"commits\":[\"PHID-CMIT-kvz2f3rczvi6exmvtyaq\"],\"reviewers\":{\"PHID-PROJ-3dvcxzznrjru2xmmses3\":\"PHID-PROJ-3dvcxzznrjru2xmmses3\"},\"ccs\":[\"PHID-USER-cgcdlc6c3gpxapbmkwa2\",\"PHID-USER-q42dn7cc3donqriafhjx\"],\"hashes\":[],\"auxiliary\":{\"phabricator:projects\":[],\"phabricator:depends-on\":[\"PHID-DREV-a77jfv32jtxfwxngd6bd\"]},\"repositoryPHID\":\"PHID-REPO-bvunnehri4u2isyr7bc3\"}],\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "headers": {
                    "content-length": [
                        "58"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ], 
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 4.7.1+861-aa7e312375cf)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ]
                }, 
                "uri": "https://phab.mercurial-scm.org//api/differential.query", 
                "method": "POST", 
                "body": "ids%5B0%5D=4480&api.token=cli-hahayouwish"
            }
        }, 
        {
            "response": {
                "headers": {
                    "cache-control": [
                        "no-store"
                    ], 
                    "set-cookie": [
                        "phsid=A%2Floppdxhbjv46vg5mwnf2squrj4vgegsce5fwhhb6; expires=Thu, 14-Sep-2023 04:15:57 GMT; Max-Age=157680000; path=/; domain=phab.mercurial-scm.org; secure; httponly"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "date": [
                        "Sat, 15 Sep 2018 04:15:57 GMT"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":{\"11058\":{\"id\":\"11058\",\"revisionID\":\"4480\",\"dateCreated\":\"1536771503\",\"dateModified\":\"1536981352\",\"sourceControlBaseRevision\":\"a5de21c9e3703f8e8eb064bd7d893ff2f703c66a\",\"sourceControlPath\":null,\"sourceControlSystem\":\"hg\",\"branch\":null,\"bookmark\":null,\"creationMethod\":\"commit\",\"description\":\"rHGa86d21e70b2b79d5e7e1085e5e755b4b26b8676d\",\"unitStatus\":\"6\",\"lintStatus\":\"6\",\"changes\":[{\"id\":\"24371\",\"metadata\":{\"line:first\":59},\"oldPath\":\"tests\\/wireprotohelpers.sh\",\"currentPath\":\"tests\\/wireprotohelpers.sh\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":[],\"type\":\"2\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"7\",\"delLines\":\"0\",\"hunks\":[{\"oldOffset\":\"1\",\"newOffset\":\"1\",\"oldLength\":\"58\",\"newLength\":\"65\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\" HTTPV2=exp-http-v2-0001\\n MEDIATYPE=application\\/mercurial-exp-framing-0005\\n \\n sendhttpraw() {\\n   hg --verbose debugwireproto --peer raw http:\\/\\/$LOCALIP:$HGPORT\\/\\n }\\n \\n sendhttpv2peer() {\\n   hg --verbose debugwireproto --nologhandshake --peer http2 http:\\/\\/$LOCALIP:$HGPORT\\/\\n }\\n \\n sendhttpv2peerhandshake() {\\n   hg --verbose debugwireproto --peer http2 http:\\/\\/$LOCALIP:$HGPORT\\/\\n }\\n \\n cat \\u003e dummycommands.py \\u003c\\u003c EOF\\n from mercurial import (\\n     wireprototypes,\\n     wireprotov1server,\\n     wireprotov2server,\\n )\\n \\n @wireprotov1server.wireprotocommand(b'customreadonly', permission=b'pull')\\n def customreadonlyv1(repo, proto):\\n     return wireprototypes.bytesresponse(b'customreadonly bytes response')\\n \\n @wireprotov2server.wireprotocommand(b'customreadonly', permission=b'pull')\\n def customreadonlyv2(repo, proto):\\n     yield b'customreadonly bytes response'\\n \\n @wireprotov1server.wireprotocommand(b'customreadwrite', permission=b'push')\\n def customreadwrite(repo, proto):\\n     return wireprototypes.bytesresponse(b'customreadwrite bytes response')\\n \\n @wireprotov2server.wireprotocommand(b'customreadwrite', permission=b'push')\\n def customreadwritev2(repo, proto):\\n     yield b'customreadwrite bytes response'\\n EOF\\n \\n cat \\u003e\\u003e $HGRCPATH \\u003c\\u003c EOF\\n [extensions]\\n drawdag = $TESTDIR\\/drawdag.py\\n EOF\\n \\n enabledummycommands() {\\n   cat \\u003e\\u003e $HGRCPATH \\u003c\\u003c EOF\\n [extensions]\\n dummycommands = $TESTTMP\\/dummycommands.py\\n EOF\\n }\\n \\n enablehttpv2() {\\n   cat \\u003e\\u003e $1\\/.hg\\/hgrc \\u003c\\u003c EOF\\n [experimental]\\n web.apiserver = true\\n web.api.http-v2 = true\\n EOF\\n }\\n+\\n+enablehttpv2client() {\\n+  cat \\u003e\\u003e $HGRCPATH \\u003c\\u003c EOF\\n+[experimental]\\n+httppeer.advertise-v2 = true\\n+EOF\\n+}\\n\"}]},{\"id\":\"24370\",\"metadata\":{\"line:first\":1},\"oldPath\":null,\"currentPath\":\"tests\\/test-wireproto-exchangev2.t\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":{\"unix:filemode\":\"100644\"},\"type\":\"1\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"53\",\"delLines\":\"0\",\"hunks\":[{\"oldOffset\":\"0\",\"newOffset\":\"1\",\"oldLength\":\"0\",\"newLength\":\"53\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\"+Tests for wire protocol version 2 exchange.\\n+Tests in this file should be folded into existing tests once protocol\\n+v2 has enough features that it can be enabled via #testcase in existing\\n+tests.\\n+\\n+  $ . $TESTDIR\\/wireprotohelpers.sh\\n+  $ enablehttpv2client\\n+\\n+  $ hg init server-simple\\n+  $ enablehttpv2 server-simple\\n+  $ cd server-simple\\n+  $ cat \\u003e\\u003e .hg\\/hgrc \\u003c\\u003c EOF\\n+  \\u003e [phases]\\n+  \\u003e publish = false\\n+  \\u003e EOF\\n+  $ echo a0 \\u003e a\\n+  $ echo b0 \\u003e b\\n+  $ hg -q commit -A -m 'commit 0'\\n+\\n+  $ echo a1 \\u003e a\\n+  $ hg commit -m 'commit 1'\\n+  $ hg phase --public -r .\\n+  $ echo a2 \\u003e a\\n+  $ hg commit -m 'commit 2'\\n+\\n+  $ hg -q up -r 0\\n+  $ echo b1 \\u003e b\\n+  $ hg -q commit -m 'head 2 commit 1'\\n+  $ echo b2 \\u003e b\\n+  $ hg -q commit -m 'head 2 commit 2'\\n+\\n+  $ hg serve -p $HGPORT -d --pid-file hg.pid -E error.log\\n+  $ cat hg.pid \\u003e $DAEMON_PIDS\\n+\\n+  $ cd ..\\n+\\n+Test basic clone\\n+\\n+  $ hg --debug clone -U http:\\/\\/localhost:$HGPORT client-simple\\n+  using http:\\/\\/localhost:$HGPORT\\/\\n+  sending capabilities command\\n+  query 1; heads\\n+  sending 2 commands\\n+  sending command heads: {}\\n+  sending command known: {\\n+    'nodes': []\\n+  }\\n+  received frame(size=11; request=1; stream=2; streamflags=stream-begin; type=command-response; flags=continuation)\\n+  received frame(size=43; request=1; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=0; request=1; stream=2; streamflags=; type=command-response; flags=eos)\\n+  received frame(size=11; request=3; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=1; request=3; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=0; request=3; stream=2; streamflags=; type=command-response; flags=eos)\\n\"}]},{\"id\":\"24369\",\"metadata\":{\"line:first\":805},\"oldPath\":\"mercurial\\/httppeer.py\",\"currentPath\":\"mercurial\\/httppeer.py\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":[],\"type\":\"2\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"2\",\"delLines\":\"1\",\"hunks\":[{\"oldOffset\":\"1\",\"newOffset\":\"1\",\"oldLength\":\"1006\",\"newLength\":\"1007\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\" # httppeer.py - HTTP repository proxy classes for mercurial\\n #\\n # Copyright 2005, 2006 Matt Mackall \\u003cmpm@selenic.com\\u003e\\n # Copyright 2006 Vadim Gelfer \\u003cvadim.gelfer@gmail.com\\u003e\\n #\\n # This software may be used and distributed according to the terms of the\\n # GNU General Public License version 2 or any later version.\\n \\n from __future__ import absolute_import\\n \\n import errno\\n import io\\n import os\\n import socket\\n import struct\\n import weakref\\n \\n from .i18n import _\\n from . import (\\n     bundle2,\\n     error,\\n     httpconnection,\\n     pycompat,\\n     repository,\\n     statichttprepo,\\n     url as urlmod,\\n     util,\\n     wireprotoframing,\\n     wireprototypes,\\n     wireprotov1peer,\\n     wireprotov2peer,\\n     wireprotov2server,\\n )\\n from .utils import (\\n     cborutil,\\n     interfaceutil,\\n     stringutil,\\n )\\n \\n httplib = util.httplib\\n urlerr = util.urlerr\\n urlreq = util.urlreq\\n \\n def encodevalueinheaders(value, header, limit):\\n     \\\"\\\"\\\"Encode a string value into multiple HTTP headers.\\n \\n     ``value`` will be encoded into 1 or more HTTP headers with the names\\n     ``header-\\u003cN\\u003e`` where ``\\u003cN\\u003e`` is an integer starting at 1. Each header\\n     name + value will be at most ``limit`` bytes long.\\n \\n     Returns an iterable of 2-tuples consisting of header names and\\n     values as native strings.\\n     \\\"\\\"\\\"\\n     # HTTP Headers are ASCII. Python 3 requires them to be unicodes,\\n     # not bytes. This function always takes bytes in as arguments.\\n     fmt = pycompat.strurl(header) + r'-%s'\\n     # Note: it is *NOT* a bug that the last bit here is a bytestring\\n     # and not a unicode: we're just getting the encoded length anyway,\\n     # and using an r-string to make it portable between Python 2 and 3\\n     # doesn't work because then the \\\\r is a literal backslash-r\\n     # instead of a carriage return.\\n     valuelen = limit - len(fmt % r'000') - len(': \\\\r\\\\n')\\n     result = []\\n \\n     n = 0\\n     for i in pycompat.xrange(0, len(value), valuelen):\\n         n += 1\\n         result.append((fmt % str(n), pycompat.strurl(value[i:i + valuelen])))\\n \\n     return result\\n \\n def _wraphttpresponse(resp):\\n     \\\"\\\"\\\"Wrap an HTTPResponse with common error handlers.\\n \\n     This ensures that any I\\/O from any consumer raises the appropriate\\n     error and messaging.\\n     \\\"\\\"\\\"\\n     origread = resp.read\\n \\n     class readerproxy(resp.__class__):\\n         def read(self, size=None):\\n             try:\\n                 return origread(size)\\n             except httplib.IncompleteRead as e:\\n                 # e.expected is an integer if length known or None otherwise.\\n                 if e.expected:\\n                     got = len(e.partial)\\n                     total = e.expected + got\\n                     msg = _('HTTP request error (incomplete response; '\\n                             'expected %d bytes got %d)') % (total, got)\\n                 else:\\n                     msg = _('HTTP request error (incomplete response)')\\n \\n                 raise error.PeerTransportError(\\n                     msg,\\n                     hint=_('this may be an intermittent network failure; '\\n                            'if the error persists, consider contacting the '\\n                            'network or server operator'))\\n             except httplib.HTTPException as e:\\n                 raise error.PeerTransportError(\\n                     _('HTTP request error (%s)') % e,\\n                     hint=_('this may be an intermittent network failure; '\\n                            'if the error persists, consider contacting the '\\n                            'network or server operator'))\\n \\n     resp.__class__ = readerproxy\\n \\n class _multifile(object):\\n     def __init__(self, *fileobjs):\\n         for f in fileobjs:\\n             if not util.safehasattr(f, 'length'):\\n                 raise ValueError(\\n                     '_multifile only supports file objects that '\\n                     'have a length but this one does not:', type(f), f)\\n         self._fileobjs = fileobjs\\n         self._index = 0\\n \\n     @property\\n     def length(self):\\n         return sum(f.length for f in self._fileobjs)\\n \\n     def read(self, amt=None):\\n         if amt \\u003c= 0:\\n             return ''.join(f.read() for f in self._fileobjs)\\n         parts = []\\n         while amt and self._index \\u003c len(self._fileobjs):\\n             parts.append(self._fileobjs[self._index].read(amt))\\n             got = len(parts[-1])\\n             if got \\u003c amt:\\n                 self._index += 1\\n             amt -= got\\n         return ''.join(parts)\\n \\n     def seek(self, offset, whence=os.SEEK_SET):\\n         if whence != os.SEEK_SET:\\n             raise NotImplementedError(\\n                 '_multifile does not support anything other'\\n                 ' than os.SEEK_SET for whence on seek()')\\n         if offset != 0:\\n             raise NotImplementedError(\\n                 '_multifile only supports seeking to start, but that '\\n                 'could be fixed if you need it')\\n         for f in self._fileobjs:\\n             f.seek(0)\\n         self._index = 0\\n \\n def makev1commandrequest(ui, requestbuilder, caps, capablefn,\\n                          repobaseurl, cmd, args):\\n     \\\"\\\"\\\"Make an HTTP request to run a command for a version 1 client.\\n \\n     ``caps`` is a set of known server capabilities. The value may be\\n     None if capabilities are not yet known.\\n \\n     ``capablefn`` is a function to evaluate a capability.\\n \\n     ``cmd``, ``args``, and ``data`` define the command, its arguments, and\\n     raw data to pass to it.\\n     \\\"\\\"\\\"\\n     if cmd == 'pushkey':\\n         args['data'] = ''\\n     data = args.pop('data', None)\\n     headers = args.pop('headers', {})\\n \\n     ui.debug(\\\"sending %s command\\\\n\\\" % cmd)\\n     q = [('cmd', cmd)]\\n     headersize = 0\\n     # Important: don't use self.capable() here or else you end up\\n     # with infinite recursion when trying to look up capabilities\\n     # for the first time.\\n     postargsok = caps is not None and 'httppostargs' in caps\\n \\n     # Send arguments via POST.\\n     if postargsok and args:\\n         strargs = urlreq.urlencode(sorted(args.items()))\\n         if not data:\\n             data = strargs\\n         else:\\n             if isinstance(data, bytes):\\n                 i = io.BytesIO(data)\\n                 i.length = len(data)\\n                 data = i\\n             argsio = io.BytesIO(strargs)\\n             argsio.length = len(strargs)\\n             data = _multifile(argsio, data)\\n         headers[r'X-HgArgs-Post'] = len(strargs)\\n     elif args:\\n         # Calling self.capable() can infinite loop if we are calling\\n         # \\\"capabilities\\\". But that command should never accept wire\\n         # protocol arguments. So this should never happen.\\n         assert cmd != 'capabilities'\\n         httpheader = capablefn('httpheader')\\n         if httpheader:\\n             headersize = int(httpheader.split(',', 1)[0])\\n \\n         # Send arguments via HTTP headers.\\n         if headersize \\u003e 0:\\n             # The headers can typically carry more data than the URL.\\n             encargs = urlreq.urlencode(sorted(args.items()))\\n             for header, value in encodevalueinheaders(encargs, 'X-HgArg',\\n                                                       headersize):\\n                 headers[header] = value\\n         # Send arguments via query string (Mercurial \\u003c1.9).\\n         else:\\n             q += sorted(args.items())\\n \\n     qs = '?%s' % urlreq.urlencode(q)\\n     cu = \\\"%s%s\\\" % (repobaseurl, qs)\\n     size = 0\\n     if util.safehasattr(data, 'length'):\\n         size = data.length\\n     elif data is not None:\\n         size = len(data)\\n     if data is not None and r'Content-Type' not in headers:\\n         headers[r'Content-Type'] = r'application\\/mercurial-0.1'\\n \\n     # Tell the server we accept application\\/mercurial-0.2 and multiple\\n     # compression formats if the server is capable of emitting those\\n     # payloads.\\n     # Note: Keep this set empty by default, as client advertisement of\\n     # protocol parameters should only occur after the handshake.\\n     protoparams = set()\\n \\n     mediatypes = set()\\n     if caps is not None:\\n         mt = capablefn('httpmediatype')\\n         if mt:\\n             protoparams.add('0.1')\\n             mediatypes = set(mt.split(','))\\n \\n         protoparams.add('partial-pull')\\n \\n     if '0.2tx' in mediatypes:\\n         protoparams.add('0.2')\\n \\n     if '0.2tx' in mediatypes and capablefn('compression'):\\n         # We \\/could\\/ compare supported compression formats and prune\\n         # non-mutually supported or error if nothing is mutually supported.\\n         # For now, send the full list to the server and have it error.\\n         comps = [e.wireprotosupport().name for e in\\n                  util.compengines.supportedwireengines(util.CLIENTROLE)]\\n         protoparams.add('comp=%s' % ','.join(comps))\\n \\n     if protoparams:\\n         protoheaders = encodevalueinheaders(' '.join(sorted(protoparams)),\\n                                             'X-HgProto',\\n                                             headersize or 1024)\\n         for header, value in protoheaders:\\n             headers[header] = value\\n \\n     varyheaders = []\\n     for header in headers:\\n         if header.lower().startswith(r'x-hg'):\\n             varyheaders.append(header)\\n \\n     if varyheaders:\\n         headers[r'Vary'] = r','.join(sorted(varyheaders))\\n \\n     req = requestbuilder(pycompat.strurl(cu), data, headers)\\n \\n     if data is not None:\\n         ui.debug(\\\"sending %d bytes\\\\n\\\" % size)\\n         req.add_unredirected_header(r'Content-Length', r'%d' % size)\\n \\n     return req, cu, qs\\n \\n def _reqdata(req):\\n     \\\"\\\"\\\"Get request data, if any. If no data, returns None.\\\"\\\"\\\"\\n     if pycompat.ispy3:\\n         return req.data\\n     if not req.has_data():\\n         return None\\n     return req.get_data()\\n \\n def sendrequest(ui, opener, req):\\n     \\\"\\\"\\\"Send a prepared HTTP request.\\n \\n     Returns the response object.\\n     \\\"\\\"\\\"\\n     dbg = ui.debug\\n     if (ui.debugflag\\n         and ui.configbool('devel', 'debug.peer-request')):\\n         line = 'devel-peer-request: %s\\\\n'\\n         dbg(line % '%s %s' % (pycompat.bytesurl(req.get_method()),\\n                               pycompat.bytesurl(req.get_full_url())))\\n         hgargssize = None\\n \\n         for header, value in sorted(req.header_items()):\\n             header = pycompat.bytesurl(header)\\n             value = pycompat.bytesurl(value)\\n             if header.startswith('X-hgarg-'):\\n                 if hgargssize is None:\\n                     hgargssize = 0\\n                 hgargssize += len(value)\\n             else:\\n                 dbg(line % '  %s %s' % (header, value))\\n \\n         if hgargssize is not None:\\n             dbg(line % '  %d bytes of commands arguments in headers'\\n                 % hgargssize)\\n         data = _reqdata(req)\\n         if data is not None:\\n             length = getattr(data, 'length', None)\\n             if length is None:\\n                 length = len(data)\\n             dbg(line % '  %d bytes of data' % length)\\n \\n         start = util.timer()\\n \\n     res = None\\n     try:\\n         res = opener.open(req)\\n     except urlerr.httperror as inst:\\n         if inst.code == 401:\\n             raise error.Abort(_('authorization failed'))\\n         raise\\n     except httplib.HTTPException as inst:\\n         ui.debug('http error requesting %s\\\\n' %\\n                  util.hidepassword(req.get_full_url()))\\n         ui.traceback()\\n         raise IOError(None, inst)\\n     finally:\\n         if ui.debugflag and ui.configbool('devel', 'debug.peer-request'):\\n             code = res.code if res else -1\\n             dbg(line % '  finished in %.4f seconds (%d)'\\n                 % (util.timer() - start, code))\\n \\n     # Insert error handlers for common I\\/O failures.\\n     _wraphttpresponse(res)\\n \\n     return res\\n \\n class RedirectedRepoError(error.RepoError):\\n     def __init__(self, msg, respurl):\\n         super(RedirectedRepoError, self).__init__(msg)\\n         self.respurl = respurl\\n \\n def parsev1commandresponse(ui, baseurl, requrl, qs, resp, compressible,\\n                            allowcbor=False):\\n     # record the url we got redirected to\\n     redirected = False\\n     respurl = pycompat.bytesurl(resp.geturl())\\n     if respurl.endswith(qs):\\n         respurl = respurl[:-len(qs)]\\n         qsdropped = False\\n     else:\\n         qsdropped = True\\n \\n     if baseurl.rstrip('\\/') != respurl.rstrip('\\/'):\\n         redirected = True\\n         if not ui.quiet:\\n             ui.warn(_('real URL is %s\\\\n') % respurl)\\n \\n     try:\\n         proto = pycompat.bytesurl(resp.getheader(r'content-type', r''))\\n     except AttributeError:\\n         proto = pycompat.bytesurl(resp.headers.get(r'content-type', r''))\\n \\n     safeurl = util.hidepassword(baseurl)\\n     if proto.startswith('application\\/hg-error'):\\n         raise error.OutOfBandError(resp.read())\\n \\n     # Pre 1.0 versions of Mercurial used text\\/plain and\\n     # application\\/hg-changegroup. We don't support such old servers.\\n     if not proto.startswith('application\\/mercurial-'):\\n         ui.debug(\\\"requested URL: '%s'\\\\n\\\" % util.hidepassword(requrl))\\n         msg = _(\\\"'%s' does not appear to be an hg repository:\\\\n\\\"\\n                 \\\"---%%\\u003c--- (%s)\\\\n%s\\\\n---%%\\u003c---\\\\n\\\") % (\\n             safeurl, proto or 'no content-type', resp.read(1024))\\n \\n         # Some servers may strip the query string from the redirect. We\\n         # raise a special error type so callers can react to this specially.\\n         if redirected and qsdropped:\\n             raise RedirectedRepoError(msg, respurl)\\n         else:\\n             raise error.RepoError(msg)\\n \\n     try:\\n         subtype = proto.split('-', 1)[1]\\n \\n         # Unless we end up supporting CBOR in the legacy wire protocol,\\n         # this should ONLY be encountered for the initial capabilities\\n         # request during handshake.\\n         if subtype == 'cbor':\\n             if allowcbor:\\n                 return respurl, proto, resp\\n             else:\\n                 raise error.RepoError(_('unexpected CBOR response from '\\n                                         'server'))\\n \\n         version_info = tuple([int(n) for n in subtype.split('.')])\\n     except ValueError:\\n         raise error.RepoError(_(\\\"'%s' sent a broken Content-Type \\\"\\n                                 \\\"header (%s)\\\") % (safeurl, proto))\\n \\n     # TODO consider switching to a decompression reader that uses\\n     # generators.\\n     if version_info == (0, 1):\\n         if compressible:\\n             resp = util.compengines['zlib'].decompressorreader(resp)\\n \\n     elif version_info == (0, 2):\\n         # application\\/mercurial-0.2 always identifies the compression\\n         # engine in the payload header.\\n         elen = struct.unpack('B', util.readexactly(resp, 1))[0]\\n         ename = util.readexactly(resp, elen)\\n         engine = util.compengines.forwiretype(ename)\\n \\n         resp = engine.decompressorreader(resp)\\n     else:\\n         raise error.RepoError(_(\\\"'%s' uses newer protocol %s\\\") %\\n                               (safeurl, subtype))\\n \\n     return respurl, proto, resp\\n \\n class httppeer(wireprotov1peer.wirepeer):\\n     def __init__(self, ui, path, url, opener, requestbuilder, caps):\\n         self.ui = ui\\n         self._path = path\\n         self._url = url\\n         self._caps = caps\\n         self._urlopener = opener\\n         self._requestbuilder = requestbuilder\\n \\n     def __del__(self):\\n         for h in self._urlopener.handlers:\\n             h.close()\\n             getattr(h, \\\"close_all\\\", lambda: None)()\\n \\n     # Begin of ipeerconnection interface.\\n \\n     def url(self):\\n         return self._path\\n \\n     def local(self):\\n         return None\\n \\n     def peer(self):\\n         return self\\n \\n     def canpush(self):\\n         return True\\n \\n     def close(self):\\n         pass\\n \\n     # End of ipeerconnection interface.\\n \\n     # Begin of ipeercommands interface.\\n \\n     def capabilities(self):\\n         return self._caps\\n \\n     # End of ipeercommands interface.\\n \\n     def _callstream(self, cmd, _compressible=False, **args):\\n         args = pycompat.byteskwargs(args)\\n \\n         req, cu, qs = makev1commandrequest(self.ui, self._requestbuilder,\\n                                            self._caps, self.capable,\\n                                            self._url, cmd, args)\\n \\n         resp = sendrequest(self.ui, self._urlopener, req)\\n \\n         self._url, ct, resp = parsev1commandresponse(self.ui, self._url, cu, qs,\\n                                                      resp, _compressible)\\n \\n         return resp\\n \\n     def _call(self, cmd, **args):\\n         fp = self._callstream(cmd, **args)\\n         try:\\n             return fp.read()\\n         finally:\\n             # if using keepalive, allow connection to be reused\\n             fp.close()\\n \\n     def _callpush(self, cmd, cg, **args):\\n         # have to stream bundle to a temp file because we do not have\\n         # http 1.1 chunked transfer.\\n \\n         types = self.capable('unbundle')\\n         try:\\n             types = types.split(',')\\n         except AttributeError:\\n             # servers older than d1b16a746db6 will send 'unbundle' as a\\n             # boolean capability. They only support headerless\\/uncompressed\\n             # bundles.\\n             types = [\\\"\\\"]\\n         for x in types:\\n             if x in bundle2.bundletypes:\\n                 type = x\\n                 break\\n \\n         tempname = bundle2.writebundle(self.ui, cg, None, type)\\n         fp = httpconnection.httpsendfile(self.ui, tempname, \\\"rb\\\")\\n         headers = {r'Content-Type': r'application\\/mercurial-0.1'}\\n \\n         try:\\n             r = self._call(cmd, data=fp, headers=headers, **args)\\n             vals = r.split('\\\\n', 1)\\n             if len(vals) \\u003c 2:\\n                 raise error.ResponseError(_(\\\"unexpected response:\\\"), r)\\n             return vals\\n         except urlerr.httperror:\\n             # Catch and re-raise these so we don't try and treat them\\n             # like generic socket errors. They lack any values in\\n             # .args on Python 3 which breaks our socket.error block.\\n             raise\\n         except socket.error as err:\\n             if err.args[0] in (errno.ECONNRESET, errno.EPIPE):\\n                 raise error.Abort(_('push failed: %s') % err.args[1])\\n             raise error.Abort(err.args[1])\\n         finally:\\n             fp.close()\\n             os.unlink(tempname)\\n \\n     def _calltwowaystream(self, cmd, fp, **args):\\n         fh = None\\n         fp_ = None\\n         filename = None\\n         try:\\n             # dump bundle to disk\\n             fd, filename = pycompat.mkstemp(prefix=\\\"hg-bundle-\\\", suffix=\\\".hg\\\")\\n             fh = os.fdopen(fd, r\\\"wb\\\")\\n             d = fp.read(4096)\\n             while d:\\n                 fh.write(d)\\n                 d = fp.read(4096)\\n             fh.close()\\n             # start http push\\n             fp_ = httpconnection.httpsendfile(self.ui, filename, \\\"rb\\\")\\n             headers = {r'Content-Type': r'application\\/mercurial-0.1'}\\n             return self._callstream(cmd, data=fp_, headers=headers, **args)\\n         finally:\\n             if fp_ is not None:\\n                 fp_.close()\\n             if fh is not None:\\n                 fh.close()\\n                 os.unlink(filename)\\n \\n     def _callcompressable(self, cmd, **args):\\n         return self._callstream(cmd, _compressible=True, **args)\\n \\n     def _abort(self, exception):\\n         raise exception\\n \\n def sendv2request(ui, opener, requestbuilder, apiurl, permission, requests):\\n     reactor = wireprotoframing.clientreactor(hasmultiplesend=False,\\n                                              buffersends=True)\\n \\n     handler = wireprotov2peer.clienthandler(ui, reactor)\\n \\n     url = '%s\\/%s' % (apiurl, permission)\\n \\n     if len(requests) \\u003e 1:\\n         url += '\\/multirequest'\\n     else:\\n         url += '\\/%s' % requests[0][0]\\n \\n     ui.debug('sending %d commands\\\\n' % len(requests))\\n     for command, args, f in requests:\\n         ui.debug('sending command %s: %s\\\\n' % (\\n             command, stringutil.pprint(args, indent=2)))\\n         assert not list(handler.callcommand(command, args, f))\\n \\n     # TODO stream this.\\n     body = b''.join(map(bytes, handler.flushcommands()))\\n \\n     # TODO modify user-agent to reflect v2\\n     headers = {\\n         r'Accept': wireprotov2server.FRAMINGTYPE,\\n         r'Content-Type': wireprotov2server.FRAMINGTYPE,\\n     }\\n \\n     req = requestbuilder(pycompat.strurl(url), body, headers)\\n     req.add_unredirected_header(r'Content-Length', r'%d' % len(body))\\n \\n     try:\\n         res = opener.open(req)\\n     except urlerr.httperror as e:\\n         if e.code == 401:\\n             raise error.Abort(_('authorization failed'))\\n \\n         raise\\n     except httplib.HTTPException as e:\\n         ui.traceback()\\n         raise IOError(None, e)\\n \\n     return handler, res\\n \\n class queuedcommandfuture(pycompat.futures.Future):\\n     \\\"\\\"\\\"Wraps result() on command futures to trigger submission on call.\\\"\\\"\\\"\\n \\n     def result(self, timeout=None):\\n         if self.done():\\n             return pycompat.futures.Future.result(self, timeout)\\n \\n         self._peerexecutor.sendcommands()\\n \\n         # sendcommands() will restore the original __class__ and self.result\\n         # will resolve to Future.result.\\n         return self.result(timeout)\\n \\n @interfaceutil.implementer(repository.ipeercommandexecutor)\\n class httpv2executor(object):\\n     def __init__(self, ui, opener, requestbuilder, apiurl, descriptor):\\n         self._ui = ui\\n         self._opener = opener\\n         self._requestbuilder = requestbuilder\\n         self._apiurl = apiurl\\n         self._descriptor = descriptor\\n         self._sent = False\\n         self._closed = False\\n         self._neededpermissions = set()\\n         self._calls = []\\n         self._futures = weakref.WeakSet()\\n         self._responseexecutor = None\\n         self._responsef = None\\n \\n     def __enter__(self):\\n         return self\\n \\n     def __exit__(self, exctype, excvalue, exctb):\\n         self.close()\\n \\n     def callcommand(self, command, args):\\n         if self._sent:\\n             raise error.ProgrammingError('callcommand() cannot be used after '\\n                                          'commands are sent')\\n \\n         if self._closed:\\n             raise error.ProgrammingError('callcommand() cannot be used after '\\n                                          'close()')\\n \\n         # The service advertises which commands are available. So if we attempt\\n         # to call an unknown command or pass an unknown argument, we can screen\\n         # for this.\\n         if command not in self._descriptor['commands']:\\n             raise error.ProgrammingError(\\n                 'wire protocol command %s is not available' % command)\\n \\n         cmdinfo = self._descriptor['commands'][command]\\n         unknownargs = set(args.keys()) - set(cmdinfo.get('args', {}))\\n \\n         if unknownargs:\\n             raise error.ProgrammingError(\\n                 'wire protocol command %s does not accept argument: %s' % (\\n                     command, ', '.join(sorted(unknownargs))))\\n \\n         self._neededpermissions |= set(cmdinfo['permissions'])\\n \\n         # TODO we \\/could\\/ also validate types here, since the API descriptor\\n         # includes types...\\n \\n         f = pycompat.futures.Future()\\n \\n         # Monkeypatch it so result() triggers sendcommands(), otherwise result()\\n         # could deadlock.\\n         f.__class__ = queuedcommandfuture\\n         f._peerexecutor = self\\n \\n         self._futures.add(f)\\n         self._calls.append((command, args, f))\\n \\n         return f\\n \\n     def sendcommands(self):\\n         if self._sent:\\n             return\\n \\n         if not self._calls:\\n             return\\n \\n         self._sent = True\\n \\n         # Unhack any future types so caller sees a clean type and so we\\n         # break reference cycle.\\n         for f in self._futures:\\n             if isinstance(f, queuedcommandfuture):\\n                 f.__class__ = pycompat.futures.Future\\n                 f._peerexecutor = None\\n \\n         # Mark the future as running and filter out cancelled futures.\\n         calls = [(command, args, f)\\n                  for command, args, f in self._calls\\n                  if f.set_running_or_notify_cancel()]\\n \\n         # Clear out references, prevent improper object usage.\\n         self._calls = None\\n \\n         if not calls:\\n             return\\n \\n         permissions = set(self._neededpermissions)\\n \\n         if 'push' in permissions and 'pull' in permissions:\\n             permissions.remove('pull')\\n \\n         if len(permissions) \\u003e 1:\\n             raise error.RepoError(_('cannot make request requiring multiple '\\n                                     'permissions: %s') %\\n                                   _(', ').join(sorted(permissions)))\\n \\n         permission = {\\n             'push': 'rw',\\n             'pull': 'ro',\\n         }[permissions.pop()]\\n \\n         handler, resp = sendv2request(\\n             self._ui, self._opener, self._requestbuilder, self._apiurl,\\n             permission, calls)\\n \\n         # TODO we probably want to validate the HTTP code, media type, etc.\\n \\n         self._responseexecutor = pycompat.futures.ThreadPoolExecutor(1)\\n         self._responsef = self._responseexecutor.submit(self._handleresponse,\\n                                                         handler, resp)\\n \\n     def close(self):\\n         if self._closed:\\n             return\\n \\n         self.sendcommands()\\n \\n         self._closed = True\\n \\n         if not self._responsef:\\n             return\\n \\n         # TODO ^C here may not result in immediate program termination.\\n \\n         try:\\n             self._responsef.result()\\n         finally:\\n             self._responseexecutor.shutdown(wait=True)\\n             self._responsef = None\\n             self._responseexecutor = None\\n \\n             # If any of our futures are still in progress, mark them as\\n             # errored, otherwise a result() could wait indefinitely.\\n             for f in self._futures:\\n                 if not f.done():\\n                     f.set_exception(error.ResponseError(\\n                         _('unfulfilled command response')))\\n \\n             self._futures = None\\n \\n     def _handleresponse(self, handler, resp):\\n         # Called in a thread to read the response.\\n \\n         while handler.readframe(resp):\\n             pass\\n \\n # TODO implement interface for version 2 peers\\n @interfaceutil.implementer(repository.ipeerconnection,\\n                            repository.ipeercapabilities,\\n                            repository.ipeerrequests)\\n class httpv2peer(object):\\n     def __init__(self, ui, repourl, apipath, opener, requestbuilder,\\n                  apidescriptor):\\n         self.ui = ui\\n \\n         if repourl.endswith('\\/'):\\n             repourl = repourl[:-1]\\n \\n         self._url = repourl\\n         self._apipath = apipath\\n         self._apiurl = '%s\\/%s' % (repourl, apipath)\\n         self._opener = opener\\n         self._requestbuilder = requestbuilder\\n         self._descriptor = apidescriptor\\n \\n     # Start of ipeerconnection.\\n \\n     def url(self):\\n         return self._url\\n \\n     def local(self):\\n         return None\\n \\n     def peer(self):\\n         return self\\n \\n     def canpush(self):\\n         # TODO change once implemented.\\n         return False\\n \\n     def close(self):\\n         pass\\n \\n     # End of ipeerconnection.\\n \\n     # Start of ipeercapabilities.\\n \\n     def capable(self, name):\\n         # The capabilities used internally historically map to capabilities\\n         # advertised from the \\\"capabilities\\\" wire protocol command. However,\\n         # version 2 of that command works differently.\\n \\n         # Maps to commands that are available.\\n         if name in ('branchmap', 'getbundle', 'known', 'lookup', 'pushkey'):\\n             return True\\n \\n         # Other concepts.\\n-        if name in ('bundle2',):\\n+        # TODO remove exchangev2 once we have a command implemented.\\n+        if name in ('bundle2', 'exchangev2'):\\n             return True\\n \\n         # Alias command-* to presence of command of that name.\\n         if name.startswith('command-'):\\n             return name[len('command-'):] in self._descriptor['commands']\\n \\n         return False\\n \\n     def requirecap(self, name, purpose):\\n         if self.capable(name):\\n             return\\n \\n         raise error.CapabilityError(\\n             _('cannot %s; client or remote repository does not support the %r '\\n               'capability') % (purpose, name))\\n \\n     # End of ipeercapabilities.\\n \\n     def _call(self, name, **args):\\n         with self.commandexecutor() as e:\\n             return e.callcommand(name, args).result()\\n \\n     def commandexecutor(self):\\n         return httpv2executor(self.ui, self._opener, self._requestbuilder,\\n                               self._apiurl, self._descriptor)\\n \\n # Registry of API service names to metadata about peers that handle it.\\n #\\n # The following keys are meaningful:\\n #\\n # init\\n #    Callable receiving (ui, repourl, servicepath, opener, requestbuilder,\\n #                        apidescriptor) to create a peer.\\n #\\n # priority\\n #    Integer priority for the service. If we could choose from multiple\\n #    services, we choose the one with the highest priority.\\n API_PEERS = {\\n     wireprototypes.HTTP_WIREPROTO_V2: {\\n         'init': httpv2peer,\\n         'priority': 50,\\n     },\\n }\\n \\n def performhandshake(ui, url, opener, requestbuilder):\\n     # The handshake is a request to the capabilities command.\\n \\n     caps = None\\n     def capable(x):\\n         raise error.ProgrammingError('should not be called')\\n \\n     args = {}\\n \\n     # The client advertises support for newer protocols by adding an\\n     # X-HgUpgrade-* header with a list of supported APIs and an\\n     # X-HgProto-* header advertising which serializing formats it supports.\\n     # We only support the HTTP version 2 transport and CBOR responses for\\n     # now.\\n     advertisev2 = ui.configbool('experimental', 'httppeer.advertise-v2')\\n \\n     if advertisev2:\\n         args['headers'] = {\\n             r'X-HgProto-1': r'cbor',\\n         }\\n \\n         args['headers'].update(\\n             encodevalueinheaders(' '.join(sorted(API_PEERS)),\\n                                  'X-HgUpgrade',\\n                                  # We don't know the header limit this early.\\n                                  # So make it small.\\n                                  1024))\\n \\n     req, requrl, qs = makev1commandrequest(ui, requestbuilder, caps,\\n                                            capable, url, 'capabilities',\\n                                            args)\\n     resp = sendrequest(ui, opener, req)\\n \\n     # The server may redirect us to the repo root, stripping the\\n     # ?cmd=capabilities query string from the URL. The server would likely\\n     # return HTML in this case and ``parsev1commandresponse()`` would raise.\\n     # We catch this special case and re-issue the capabilities request against\\n     # the new URL.\\n     #\\n     # We should ideally not do this, as a redirect that drops the query\\n     # string from the URL is arguably a server bug. (Garbage in, garbage out).\\n     # However,  Mercurial clients for several years appeared to handle this\\n     # issue without behavior degradation. And according to issue 5860, it may\\n     # be a longstanding bug in some server implementations. So we allow a\\n     # redirect that drops the query string to \\\"just work.\\\"\\n     try:\\n         respurl, ct, resp = parsev1commandresponse(ui, url, requrl, qs, resp,\\n                                                    compressible=False,\\n                                                    allowcbor=advertisev2)\\n     except RedirectedRepoError as e:\\n         req, requrl, qs = makev1commandrequest(ui, requestbuilder, caps,\\n                                                capable, e.respurl,\\n                                                'capabilities', args)\\n         resp = sendrequest(ui, opener, req)\\n         respurl, ct, resp = parsev1commandresponse(ui, url, requrl, qs, resp,\\n                                                    compressible=False,\\n                                                    allowcbor=advertisev2)\\n \\n     try:\\n         rawdata = resp.read()\\n     finally:\\n         resp.close()\\n \\n     if not ct.startswith('application\\/mercurial-'):\\n         raise error.ProgrammingError('unexpected content-type: %s' % ct)\\n \\n     if advertisev2:\\n         if ct == 'application\\/mercurial-cbor':\\n             try:\\n                 info = cborutil.decodeall(rawdata)[0]\\n             except cborutil.CBORDecodeError:\\n                 raise error.Abort(_('error decoding CBOR from remote server'),\\n                                   hint=_('try again and consider contacting '\\n                                          'the server operator'))\\n \\n         # We got a legacy response. That's fine.\\n         elif ct in ('application\\/mercurial-0.1', 'application\\/mercurial-0.2'):\\n             info = {\\n                 'v1capabilities': set(rawdata.split())\\n             }\\n \\n         else:\\n             raise error.RepoError(\\n                 _('unexpected response type from server: %s') % ct)\\n     else:\\n         info = {\\n             'v1capabilities': set(rawdata.split())\\n         }\\n \\n     return respurl, info\\n \\n def makepeer(ui, path, opener=None, requestbuilder=urlreq.request):\\n     \\\"\\\"\\\"Construct an appropriate HTTP peer instance.\\n \\n     ``opener`` is an ``url.opener`` that should be used to establish\\n     connections, perform HTTP requests.\\n \\n     ``requestbuilder`` is the type used for constructing HTTP requests.\\n     It exists as an argument so extensions can override the default.\\n     \\\"\\\"\\\"\\n     u = util.url(path)\\n     if u.query or u.fragment:\\n         raise error.Abort(_('unsupported URL component: \\\"%s\\\"') %\\n                           (u.query or u.fragment))\\n \\n     # urllib cannot handle URLs with embedded user or passwd.\\n     url, authinfo = u.authinfo()\\n     ui.debug('using %s\\\\n' % url)\\n \\n     opener = opener or urlmod.opener(ui, authinfo)\\n \\n     respurl, info = performhandshake(ui, url, opener, requestbuilder)\\n \\n     # Given the intersection of APIs that both we and the server support,\\n     # sort by their advertised priority and pick the first one.\\n     #\\n     # TODO consider making this request-based and interface driven. For\\n     # example, the caller could say \\\"I want a peer that does X.\\\" It's quite\\n     # possible that not all peers would do that. Since we know the service\\n     # capabilities, we could filter out services not meeting the\\n     # requirements. Possibly by consulting the interfaces defined by the\\n     # peer type.\\n     apipeerchoices = set(info.get('apis', {}).keys()) & set(API_PEERS.keys())\\n \\n     preferredchoices = sorted(apipeerchoices,\\n                               key=lambda x: API_PEERS[x]['priority'],\\n                               reverse=True)\\n \\n     for service in preferredchoices:\\n         apipath = '%s\\/%s' % (info['apibase'].rstrip('\\/'), service)\\n \\n         return API_PEERS[service]['init'](ui, respurl, apipath, opener,\\n                                           requestbuilder,\\n                                           info['apis'][service])\\n \\n     # Failed to construct an API peer. Fall back to legacy.\\n     return httppeer(ui, path, respurl, opener, requestbuilder,\\n                     info['v1capabilities'])\\n \\n def instance(ui, path, create, intents=None, createopts=None):\\n     if create:\\n         raise error.Abort(_('cannot create new http repository'))\\n     try:\\n         if path.startswith('https:') and not urlmod.has_https:\\n             raise error.Abort(_('Python support for SSL and HTTPS '\\n                                 'is not installed'))\\n \\n         inst = makepeer(ui, path)\\n \\n         return inst\\n     except error.RepoError as httpexception:\\n         try:\\n             r = statichttprepo.instance(ui, \\\"static-\\\" + path, create)\\n             ui.note(_('(falling back to static-http)\\\\n'))\\n             return r\\n         except error.RepoError:\\n             raise httpexception # use the original http RepoError instead\\n\"}]},{\"id\":\"24368\",\"metadata\":{\"line:first\":1,\"copy:lines\":{\"4\":[\"mercurial\\/exchange.py\",4,\" \"],\"5\":[\"mercurial\\/exchange.py\",5,\" \"],\"6\":[\"mercurial\\/exchange.py\",6,\" \"],\"7\":[\"mercurial\\/exchange.py\",7,\" \"],\"8\":[\"mercurial\\/exchange.py\",8,\" \"],\"9\":[\"mercurial\\/exchange.py\",9,\" \"]}},\"oldPath\":null,\"currentPath\":\"mercurial\\/exchangev2.py\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":{\"unix:filemode\":\"100644\"},\"type\":\"1\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"55\",\"delLines\":\"0\",\"hunks\":[{\"oldOffset\":\"0\",\"newOffset\":\"1\",\"oldLength\":\"0\",\"newLength\":\"55\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\"+# exchangev2.py - repository exchange for wire protocol version 2\\n+#\\n+# Copyright 2018 Gregory Szorc \\u003cgregory.szorc@gmail.com\\u003e\\n+#\\n+# This software may be used and distributed according to the terms of the\\n+# GNU General Public License version 2 or any later version.\\n+\\n+from __future__ import absolute_import\\n+\\n+from .node import (\\n+    nullid,\\n+)\\n+from . import (\\n+    setdiscovery,\\n+)\\n+\\n+def pull(pullop):\\n+    \\\"\\\"\\\"Pull using wire protocol version 2.\\\"\\\"\\\"\\n+    repo = pullop.repo\\n+    remote = pullop.remote\\n+\\n+    # Figure out what needs to be fetched.\\n+    common, fetch, remoteheads = _pullchangesetdiscovery(\\n+        repo, remote, pullop.heads, abortwhenunrelated=pullop.force)\\n+\\n+def _pullchangesetdiscovery(repo, remote, heads, abortwhenunrelated=True):\\n+    \\\"\\\"\\\"Determine which changesets need to be pulled.\\\"\\\"\\\"\\n+\\n+    if heads:\\n+        knownnode = repo.changelog.hasnode\\n+        if all(knownnode(head) for head in heads):\\n+            return heads, False, heads\\n+\\n+    # TODO wire protocol version 2 is capable of more efficient discovery\\n+    # than setdiscovery. Consider implementing something better.\\n+    common, fetch, remoteheads = setdiscovery.findcommonheads(\\n+        repo.ui, repo, remote, abortwhenunrelated=abortwhenunrelated)\\n+\\n+    common = set(common)\\n+    remoteheads = set(remoteheads)\\n+\\n+    # If a remote head is filtered locally, put it back in the common set.\\n+    # See the comment in exchange._pulldiscoverychangegroup() for more.\\n+\\n+    if fetch and remoteheads:\\n+        nodemap = repo.unfiltered().changelog.nodemap\\n+\\n+        common |= {head for head in remoteheads if head in nodemap}\\n+\\n+        if set(remoteheads).issubset(common):\\n+            fetch = []\\n+\\n+    common.discard(nullid)\\n+\\n+    return common, fetch, remoteheads\\n\"}]},{\"id\":\"24367\",\"metadata\":{\"line:first\":29,\"copy:lines\":{\"1514\":[\"\",1509,\"-\"],\"1515\":[\"\",1510,\"-\"],\"1516\":[\"\",1511,\"-\"],\"1517\":[\"\",1512,\"-\"],\"1518\":[\"\",1513,\"-\"],\"1519\":[\"\",1514,\"-\"],\"1520\":[\"\",1515,\"-\"],\"1521\":[\"\",1516,\"-\"],\"1522\":[\"\",1517,\"-\"],\"1523\":[\"\",1518,\"-\"],\"1524\":[\"\",1519,\"-\"],\"1525\":[\"\",1520,\" \"],\"1526\":[\"\",1521,\" \"],\"1527\":[\"\",1522,\" \"],\"1528\":[\"\",1523,\" \"],\"1529\":[\"\",1524,\" \"],\"1530\":[\"\",1525,\" \"],\"1531\":[\"\",1526,\" \"],\"1532\":[\"\",1527,\" \"],\"1533\":[\"\",1528,\" \"],\"1534\":[\"\",1529,\" \"],\"1535\":[\"\",1530,\" \"],\"1536\":[\"\",1531,\" \"],\"1537\":[\"\",1532,\" \"],\"1538\":[\"\",1533,\" \"],\"1539\":[\"\",1534,\" \"],\"1540\":[\"\",1535,\" \"],\"1541\":[\"\",1536,\" \"],\"1542\":[\"\",1537,\" \"],\"1543\":[\"\",1538,\" \"],\"1544\":[\"\",1539,\" \"],\"1545\":[\"\",1540,\" \"],\"1546\":[\"\",1541,\" \"],\"1547\":[\"\",1542,\" \"],\"1548\":[\"\",1543,\" \"],\"1549\":[\"\",1544,\" \"],\"1550\":[\"\",1545,\" \"],\"1551\":[\"\",1546,\" \"],\"1552\":[\"\",1547,\" \"],\"1553\":[\"\",1548,\" \"],\"1554\":[\"\",1549,\" \"],\"1555\":[\"\",1550,\" \"],\"1556\":[\"\",1551,\" \"],\"1557\":[\"\",1552,\" \"],\"1558\":[\"\",1553,\" \"],\"1559\":[\"\",1554,\" \"],\"1560\":[\"\",1555,\" \"],\"1561\":[\"\",1556,\" \"],\"1562\":[\"\",1557,\" \"],\"1563\":[\"\",1558,\" \"],\"1564\":[\"\",1559,\" \"],\"1565\":[\"\",1560,\" \"],\"1566\":[\"\",1561,\" \"],\"1567\":[\"\",1562,\" \"],\"1568\":[\"\",1563,\" \"],\"1569\":[\"\",1564,\" \"],\"1570\":[\"\",1565,\" \"],\"1571\":[\"\",1566,\" \"],\"1572\":[\"\",1567,\" \"],\"1573\":[\"\",1568,\" \"],\"1574\":[\"\",1569,\" \"],\"1575\":[\"\",1570,\" \"],\"1576\":[\"\",1571,\" \"],\"1577\":[\"\",1572,\" \"],\"1578\":[\"\",1573,\" \"],\"1579\":[\"\",1574,\" \"],\"1580\":[\"\",1575,\" \"],\"1581\":[\"\",1576,\" \"],\"1582\":[\"\",1577,\" \"],\"1583\":[\"\",1578,\" \"],\"1584\":[\"\",1579,\" \"],\"1585\":[\"\",1580,\" \"],\"1586\":[\"\",1581,\" \"],\"1587\":[\"\",1582,\" \"],\"1588\":[\"\",1583,\" \"],\"1589\":[\"\",1584,\" \"],\"1590\":[\"\",1585,\" \"],\"1591\":[\"\",1586,\" \"],\"1592\":[\"\",1587,\" \"],\"1593\":[\"\",1588,\" \"],\"1594\":[\"\",1589,\" \"],\"1595\":[\"\",1590,\" \"],\"1596\":[\"\",1591,\" \"],\"1597\":[\"\",1592,\" \"],\"1598\":[\"\",1593,\" \"],\"1599\":[\"\",1594,\" \"],\"1600\":[\"\",1595,\" \"],\"1601\":[\"\",1596,\" \"],\"1602\":[\"\",1597,\" \"],\"1603\":[\"\",1598,\" \"],\"1604\":[\"\",1599,\" \"],\"1605\":[\"\",1600,\" \"],\"1606\":[\"\",1601,\" \"],\"1607\":[\"\",1602,\" \"],\"1608\":[\"\",1603,\" \"],\"1609\":[\"\",1604,\" \"],\"1610\":[\"\",1605,\" \"],\"1611\":[\"\",1606,\" \"],\"1612\":[\"\",1607,\" \"],\"1613\":[\"\",1608,\" \"],\"1614\":[\"\",1609,\" \"],\"1615\":[\"\",1610,\" \"],\"1616\":[\"\",1611,\" \"],\"1617\":[\"\",1612,\" \"],\"1618\":[\"\",1613,\" \"],\"1619\":[\"\",1614,\" \"],\"1620\":[\"\",1615,\" \"],\"1621\":[\"\",1616,\" \"],\"1622\":[\"\",1617,\" \"],\"1623\":[\"\",1618,\" \"],\"1624\":[\"\",1619,\" \"],\"1625\":[\"\",1620,\" \"],\"1626\":[\"\",1621,\" \"],\"1627\":[\"\",1622,\" \"],\"1628\":[\"\",1623,\" \"],\"1629\":[\"\",1624,\" \"],\"1630\":[\"\",1625,\" \"],\"1631\":[\"\",1626,\" \"],\"1632\":[\"\",1627,\" \"],\"1633\":[\"\",1628,\" \"],\"1634\":[\"\",1629,\" \"],\"1635\":[\"\",1630,\" \"],\"1636\":[\"\",1631,\" \"],\"1637\":[\"\",1632,\" \"],\"1638\":[\"\",1633,\" \"],\"1639\":[\"\",1634,\" \"],\"1640\":[\"\",1635,\" \"],\"1641\":[\"\",1636,\" \"],\"1642\":[\"\",1637,\" \"],\"1643\":[\"\",1638,\" \"],\"1644\":[\"\",1639,\" \"],\"1645\":[\"\",1640,\" \"],\"1646\":[\"\",1641,\" \"],\"1647\":[\"\",1642,\" \"],\"1648\":[\"\",1643,\" \"],\"1649\":[\"\",1644,\" \"],\"1650\":[\"\",1645,\" \"],\"1651\":[\"\",1646,\" \"],\"1652\":[\"\",1647,\" \"],\"1653\":[\"\",1648,\" \"],\"1654\":[\"\",1649,\" \"],\"1655\":[\"\",1650,\" \"],\"1656\":[\"\",1651,\" \"],\"1657\":[\"\",1652,\" \"],\"1658\":[\"\",1653,\" \"],\"1659\":[\"\",1654,\" \"],\"1660\":[\"\",1655,\" \"],\"1661\":[\"\",1656,\" \"],\"1662\":[\"\",1657,\" \"],\"1663\":[\"\",1658,\" \"],\"1664\":[\"\",1659,\" \"],\"1665\":[\"\",1660,\" \"],\"1666\":[\"\",1661,\" \"],\"1667\":[\"\",1662,\" \"],\"1668\":[\"\",1663,\" \"],\"1669\":[\"\",1664,\" \"],\"1670\":[\"\",1665,\" \"],\"1671\":[\"\",1666,\" \"],\"1672\":[\"\",1667,\" \"],\"1673\":[\"\",1668,\" \"],\"1674\":[\"\",1669,\" \"],\"1675\":[\"\",1670,\" \"],\"1676\":[\"\",1671,\" \"],\"1677\":[\"\",1672,\" \"],\"1678\":[\"\",1673,\" \"],\"1679\":[\"\",1674,\" \"],\"1680\":[\"\",1675,\" \"],\"1681\":[\"\",1676,\" \"],\"1682\":[\"\",1677,\" \"],\"1683\":[\"\",1678,\" \"],\"1684\":[\"\",1679,\" \"],\"1685\":[\"\",1680,\" \"],\"1686\":[\"\",1681,\" \"],\"1687\":[\"\",1682,\" \"],\"1688\":[\"\",1683,\" \"],\"1689\":[\"\",1684,\" \"],\"1690\":[\"\",1685,\" \"],\"1691\":[\"\",1686,\" \"],\"1692\":[\"\",1687,\" \"],\"1693\":[\"\",1688,\" \"],\"1694\":[\"\",1689,\" \"],\"1695\":[\"\",1690,\" \"],\"1696\":[\"\",1691,\" \"],\"1697\":[\"\",1692,\" \"],\"1698\":[\"\",1693,\" \"],\"1699\":[\"\",1694,\" \"],\"1700\":[\"\",1695,\" \"],\"1701\":[\"\",1696,\" \"],\"1702\":[\"\",1697,\" \"],\"1703\":[\"\",1698,\" \"],\"1704\":[\"\",1699,\" \"],\"1705\":[\"\",1700,\" \"],\"1706\":[\"\",1701,\" \"],\"1707\":[\"\",1702,\" \"],\"1708\":[\"\",1703,\" \"],\"1709\":[\"\",1704,\" \"],\"1710\":[\"\",1705,\" \"],\"1711\":[\"\",1706,\" \"],\"1712\":[\"\",1707,\" \"],\"1713\":[\"\",1708,\" \"],\"1714\":[\"\",1709,\" \"],\"1715\":[\"\",1710,\" \"],\"1716\":[\"\",1711,\" \"],\"1717\":[\"\",1712,\" \"],\"1718\":[\"\",1713,\" \"],\"1719\":[\"\",1714,\" \"],\"1720\":[\"\",1715,\" \"],\"1721\":[\"\",1716,\" \"],\"1722\":[\"\",1717,\" \"],\"1723\":[\"\",1718,\" \"],\"1724\":[\"\",1719,\" \"],\"1725\":[\"\",1720,\" \"],\"1726\":[\"\",1721,\" \"],\"1727\":[\"\",1722,\" \"],\"1728\":[\"\",1723,\" \"],\"1729\":[\"\",1724,\" \"],\"1730\":[\"\",1725,\" \"],\"1731\":[\"\",1726,\" \"],\"1732\":[\"\",1727,\" \"],\"1733\":[\"\",1728,\" \"],\"1734\":[\"\",1729,\" \"],\"1735\":[\"\",1730,\" \"],\"1736\":[\"\",1731,\" \"],\"1737\":[\"\",1732,\" \"],\"1738\":[\"\",1733,\" \"],\"1739\":[\"\",1734,\" \"],\"1740\":[\"\",1735,\" \"],\"1741\":[\"\",1736,\" \"],\"1742\":[\"\",1737,\" \"],\"1743\":[\"\",1738,\" \"],\"1744\":[\"\",1739,\" \"],\"1745\":[\"\",1740,\" \"],\"1746\":[\"\",1741,\" \"],\"1747\":[\"\",1742,\" \"],\"1748\":[\"\",1743,\" \"],\"1749\":[\"\",1744,\" \"],\"1750\":[\"\",1745,\" \"],\"1751\":[\"\",1746,\" \"],\"1752\":[\"\",1747,\" \"],\"1753\":[\"\",1748,\" \"],\"1754\":[\"\",1749,\" \"],\"1755\":[\"\",1750,\" \"],\"1756\":[\"\",1751,\" \"],\"1757\":[\"\",1752,\" \"],\"1758\":[\"\",1753,\" \"],\"1759\":[\"\",1754,\" \"],\"1760\":[\"\",1755,\" \"],\"1761\":[\"\",1756,\" \"],\"1762\":[\"\",1757,\" \"],\"1763\":[\"\",1758,\" \"],\"1764\":[\"\",1759,\" \"],\"1765\":[\"\",1760,\" \"],\"1766\":[\"\",1761,\" \"],\"1767\":[\"\",1762,\" \"],\"1768\":[\"\",1763,\" \"],\"1769\":[\"\",1764,\" \"],\"1770\":[\"\",1765,\" \"],\"1771\":[\"\",1766,\" \"],\"1772\":[\"\",1767,\" \"],\"1773\":[\"\",1768,\" \"],\"1774\":[\"\",1769,\" \"],\"1775\":[\"\",1770,\" \"],\"1776\":[\"\",1771,\" \"],\"1777\":[\"\",1772,\" \"],\"1778\":[\"\",1773,\" \"],\"1779\":[\"\",1774,\" \"],\"1780\":[\"\",1775,\" \"],\"1781\":[\"\",1776,\" \"],\"1782\":[\"\",1777,\" \"],\"1783\":[\"\",1778,\" \"],\"1784\":[\"\",1779,\" \"],\"1785\":[\"\",1780,\" \"],\"1786\":[\"\",1781,\" \"],\"1787\":[\"\",1782,\" \"],\"1788\":[\"\",1783,\" \"],\"1789\":[\"\",1784,\" \"],\"1790\":[\"\",1785,\" \"],\"1791\":[\"\",1786,\" \"],\"1792\":[\"\",1787,\" \"],\"1793\":[\"\",1788,\" \"],\"1794\":[\"\",1789,\" \"],\"1795\":[\"\",1790,\" \"],\"1796\":[\"\",1791,\" \"],\"1797\":[\"\",1792,\" \"],\"1798\":[\"\",1793,\" \"],\"1799\":[\"\",1794,\" \"],\"1800\":[\"\",1795,\" \"],\"1801\":[\"\",1796,\" \"],\"1802\":[\"\",1797,\" \"],\"1803\":[\"\",1798,\" \"],\"1804\":[\"\",1799,\" \"],\"1805\":[\"\",1800,\" \"],\"1806\":[\"\",1801,\" \"],\"1807\":[\"\",1802,\" \"],\"1808\":[\"\",1803,\" \"],\"1809\":[\"\",1804,\" \"],\"1810\":[\"\",1805,\" \"],\"1811\":[\"\",1806,\" \"],\"1812\":[\"\",1807,\" \"],\"1813\":[\"\",1808,\" \"],\"1814\":[\"\",1809,\" \"],\"1815\":[\"\",1810,\" \"],\"1816\":[\"\",1811,\" \"],\"1817\":[\"\",1812,\" \"],\"1818\":[\"\",1813,\" \"],\"1819\":[\"\",1814,\" \"],\"1820\":[\"\",1815,\" \"],\"1821\":[\"\",1816,\" \"],\"1822\":[\"\",1817,\" \"],\"1823\":[\"\",1818,\" \"],\"1824\":[\"\",1819,\" \"],\"1825\":[\"\",1820,\" \"],\"1826\":[\"\",1821,\" \"],\"1827\":[\"\",1822,\" \"],\"1828\":[\"\",1823,\" \"],\"1829\":[\"\",1824,\" \"],\"1830\":[\"\",1825,\" \"],\"1831\":[\"\",1826,\" \"],\"1832\":[\"\",1827,\" \"],\"1833\":[\"\",1828,\" \"],\"1834\":[\"\",1829,\" \"],\"1835\":[\"\",1830,\" \"],\"1836\":[\"\",1831,\" \"],\"1837\":[\"\",1832,\" \"],\"1838\":[\"\",1833,\" \"],\"1839\":[\"\",1834,\" \"],\"1840\":[\"\",1835,\" \"],\"1841\":[\"\",1836,\" \"],\"1842\":[\"\",1837,\" \"],\"1843\":[\"\",1838,\" \"],\"1844\":[\"\",1839,\" \"],\"1845\":[\"\",1840,\" \"],\"1846\":[\"\",1841,\" \"],\"1847\":[\"\",1842,\" \"],\"1848\":[\"\",1843,\" \"],\"1849\":[\"\",1844,\" \"],\"1850\":[\"\",1845,\" \"],\"1851\":[\"\",1846,\" \"],\"1852\":[\"\",1847,\" \"],\"1853\":[\"\",1848,\" \"],\"1854\":[\"\",1849,\" \"],\"1855\":[\"\",1850,\" \"],\"1856\":[\"\",1851,\" \"],\"1857\":[\"\",1852,\" \"],\"1858\":[\"\",1853,\" \"],\"1859\":[\"\",1854,\" \"],\"1860\":[\"\",1855,\" \"],\"1861\":[\"\",1856,\" \"],\"1862\":[\"\",1857,\" \"],\"1863\":[\"\",1858,\" \"],\"1864\":[\"\",1859,\" \"],\"1865\":[\"\",1860,\" \"],\"1866\":[\"\",1861,\" \"],\"1867\":[\"\",1862,\" \"],\"1868\":[\"\",1863,\" \"],\"1869\":[\"\",1864,\" \"],\"1870\":[\"\",1865,\" \"],\"1871\":[\"\",1866,\" \"],\"1872\":[\"\",1867,\" \"],\"1873\":[\"\",1868,\" \"],\"1874\":[\"\",1869,\" \"],\"1875\":[\"\",1870,\" \"],\"1876\":[\"\",1871,\" \"],\"1877\":[\"\",1872,\" \"],\"1878\":[\"\",1873,\" \"],\"1879\":[\"\",1874,\" \"],\"1880\":[\"\",1875,\" \"],\"1881\":[\"\",1876,\" \"],\"1882\":[\"\",1877,\" \"],\"1883\":[\"\",1878,\" \"],\"1884\":[\"\",1879,\" \"],\"1885\":[\"\",1880,\" \"],\"1886\":[\"\",1881,\" \"],\"1887\":[\"\",1882,\" \"],\"1888\":[\"\",1883,\" \"],\"1889\":[\"\",1884,\" \"],\"1890\":[\"\",1885,\" \"],\"1891\":[\"\",1886,\" \"],\"1892\":[\"\",1887,\" \"],\"1893\":[\"\",1888,\" \"],\"1894\":[\"\",1889,\" \"],\"1895\":[\"\",1890,\" \"],\"1896\":[\"\",1891,\" \"],\"1897\":[\"\",1892,\" \"],\"1898\":[\"\",1893,\" \"],\"1899\":[\"\",1894,\" \"],\"1900\":[\"\",1895,\" \"],\"1901\":[\"\",1896,\" \"],\"1902\":[\"\",1897,\" \"],\"1903\":[\"\",1898,\" \"],\"1904\":[\"\",1899,\" \"],\"1905\":[\"\",1900,\" \"],\"1906\":[\"\",1901,\" \"],\"1907\":[\"\",1902,\" \"],\"1908\":[\"\",1903,\" \"],\"1909\":[\"\",1904,\" \"],\"1910\":[\"\",1905,\" \"],\"1911\":[\"\",1906,\" \"],\"1912\":[\"\",1907,\" \"],\"1913\":[\"\",1908,\" \"],\"1914\":[\"\",1909,\" \"],\"1915\":[\"\",1910,\" \"],\"1916\":[\"\",1911,\" \"],\"1917\":[\"\",1912,\" \"],\"1918\":[\"\",1913,\" \"],\"1919\":[\"\",1914,\" \"],\"1920\":[\"\",1915,\" \"],\"1921\":[\"\",1916,\" \"],\"1922\":[\"\",1917,\" \"],\"1923\":[\"\",1918,\" \"],\"1924\":[\"\",1919,\" \"],\"1925\":[\"\",1920,\" \"],\"1926\":[\"\",1921,\" \"],\"1927\":[\"\",1922,\" \"],\"1928\":[\"\",1923,\" \"],\"1929\":[\"\",1924,\" \"],\"1930\":[\"\",1925,\" \"],\"1931\":[\"\",1926,\" \"],\"1932\":[\"\",1927,\" \"],\"1933\":[\"\",1928,\" \"],\"1934\":[\"\",1929,\" \"],\"1935\":[\"\",1930,\" \"],\"1936\":[\"\",1931,\" \"],\"1937\":[\"\",1932,\" \"],\"1938\":[\"\",1933,\" \"],\"1939\":[\"\",1934,\" \"],\"1940\":[\"\",1935,\" \"],\"1941\":[\"\",1936,\" \"],\"1942\":[\"\",1937,\" \"],\"1943\":[\"\",1938,\" \"],\"1944\":[\"\",1939,\" \"],\"1945\":[\"\",1940,\" \"],\"1946\":[\"\",1941,\" \"],\"1947\":[\"\",1942,\" \"],\"1948\":[\"\",1943,\" \"],\"1949\":[\"\",1944,\" \"],\"1950\":[\"\",1945,\" \"],\"1951\":[\"\",1946,\" \"],\"1952\":[\"\",1947,\" \"],\"1953\":[\"\",1948,\" \"],\"1954\":[\"\",1949,\" \"],\"1955\":[\"\",1950,\" \"],\"1956\":[\"\",1951,\" \"],\"1957\":[\"\",1952,\" \"],\"1958\":[\"\",1953,\" \"],\"1959\":[\"\",1954,\" \"],\"1960\":[\"\",1955,\" \"],\"1961\":[\"\",1956,\" \"],\"1962\":[\"\",1957,\" \"],\"1963\":[\"\",1958,\" \"],\"1964\":[\"\",1959,\" \"],\"1965\":[\"\",1960,\" \"],\"1966\":[\"\",1961,\" \"],\"1967\":[\"\",1962,\" \"],\"1968\":[\"\",1963,\" \"],\"1969\":[\"\",1964,\" \"],\"1970\":[\"\",1965,\" \"],\"1971\":[\"\",1966,\" \"],\"1972\":[\"\",1967,\" \"],\"1973\":[\"\",1968,\" \"],\"1974\":[\"\",1969,\" \"],\"1975\":[\"\",1970,\" \"],\"1976\":[\"\",1971,\" \"],\"1977\":[\"\",1972,\" \"],\"1978\":[\"\",1973,\" \"],\"1979\":[\"\",1974,\" \"],\"1980\":[\"\",1975,\" \"],\"1981\":[\"\",1976,\" \"],\"1982\":[\"\",1977,\" \"],\"1983\":[\"\",1978,\" \"],\"1984\":[\"\",1979,\" \"],\"1985\":[\"\",1980,\" \"],\"1986\":[\"\",1981,\" \"],\"1987\":[\"\",1982,\" \"],\"1988\":[\"\",1983,\" \"],\"1989\":[\"\",1984,\" \"],\"1990\":[\"\",1985,\" \"],\"1991\":[\"\",1986,\" \"],\"1992\":[\"\",1987,\" \"],\"1993\":[\"\",1988,\" \"],\"1994\":[\"\",1989,\" \"],\"1995\":[\"\",1990,\" \"],\"1996\":[\"\",1991,\" \"],\"1997\":[\"\",1992,\" \"],\"1998\":[\"\",1993,\" \"],\"1999\":[\"\",1994,\" \"],\"2000\":[\"\",1995,\" \"],\"2001\":[\"\",1996,\" \"],\"2002\":[\"\",1997,\" \"],\"2003\":[\"\",1998,\" \"],\"2004\":[\"\",1999,\" \"],\"2005\":[\"\",2000,\" \"],\"2006\":[\"\",2001,\" \"],\"2007\":[\"\",2002,\" \"],\"2008\":[\"\",2003,\" \"],\"2009\":[\"\",2004,\" \"],\"2010\":[\"\",2005,\" \"],\"2011\":[\"\",2006,\" \"],\"2012\":[\"\",2007,\" \"],\"2013\":[\"\",2008,\" \"],\"2014\":[\"\",2009,\" \"],\"2015\":[\"\",2010,\" \"],\"2016\":[\"\",2011,\" \"],\"2017\":[\"\",2012,\" \"],\"2018\":[\"\",2013,\" \"],\"2019\":[\"\",2014,\" \"],\"2020\":[\"\",2015,\" \"],\"2021\":[\"\",2016,\" \"],\"2022\":[\"\",2017,\" \"],\"2023\":[\"\",2018,\" \"],\"2024\":[\"\",2019,\" \"],\"2025\":[\"\",2020,\" \"],\"2026\":[\"\",2021,\" \"],\"2027\":[\"\",2022,\" \"],\"2028\":[\"\",2023,\" \"],\"2029\":[\"\",2024,\" \"],\"2030\":[\"\",2025,\" \"],\"2031\":[\"\",2026,\" \"],\"2032\":[\"\",2027,\" \"],\"2033\":[\"\",2028,\" \"],\"2034\":[\"\",2029,\" \"],\"2035\":[\"\",2030,\" \"],\"2036\":[\"\",2031,\" \"],\"2037\":[\"\",2032,\" \"],\"2038\":[\"\",2033,\" \"],\"2039\":[\"\",2034,\" \"],\"2040\":[\"\",2035,\" \"],\"2041\":[\"\",2036,\" \"],\"2042\":[\"\",2037,\" \"],\"2043\":[\"\",2038,\" \"],\"2044\":[\"\",2039,\" \"],\"2045\":[\"\",2040,\" \"],\"2046\":[\"\",2041,\" \"],\"2047\":[\"\",2042,\" \"],\"2048\":[\"\",2043,\" \"],\"2049\":[\"\",2044,\" \"],\"2050\":[\"\",2045,\" \"],\"2051\":[\"\",2046,\" \"],\"2052\":[\"\",2047,\" \"],\"2053\":[\"\",2048,\" \"],\"2054\":[\"\",2049,\" \"],\"2055\":[\"\",2050,\" \"],\"2056\":[\"\",2051,\" \"],\"2057\":[\"\",2052,\" \"],\"2058\":[\"\",2053,\" \"],\"2059\":[\"\",2054,\" \"],\"2060\":[\"\",2055,\" \"],\"2061\":[\"\",2056,\" \"],\"2062\":[\"\",2057,\" \"],\"2063\":[\"\",2058,\" \"],\"2064\":[\"\",2059,\" \"],\"2065\":[\"\",2060,\" \"],\"2066\":[\"\",2061,\" \"],\"2067\":[\"\",2062,\" \"],\"2068\":[\"\",2063,\" \"],\"2069\":[\"\",2064,\" \"],\"2070\":[\"\",2065,\" \"],\"2071\":[\"\",2066,\" \"],\"2072\":[\"\",2067,\" \"],\"2073\":[\"\",2068,\" \"],\"2074\":[\"\",2069,\" \"],\"2075\":[\"\",2070,\" \"],\"2076\":[\"\",2071,\" \"],\"2077\":[\"\",2072,\" \"],\"2078\":[\"\",2073,\" \"],\"2079\":[\"\",2074,\" \"],\"2080\":[\"\",2075,\" \"],\"2081\":[\"\",2076,\" \"],\"2082\":[\"\",2077,\" \"],\"2083\":[\"\",2078,\" \"],\"2084\":[\"\",2079,\" \"],\"2085\":[\"\",2080,\" \"],\"2086\":[\"\",2081,\" \"],\"2087\":[\"\",2082,\" \"],\"2088\":[\"\",2083,\" \"],\"2089\":[\"\",2084,\" \"],\"2090\":[\"\",2085,\" \"],\"2091\":[\"\",2086,\" \"],\"2092\":[\"\",2087,\" \"],\"2093\":[\"\",2088,\" \"],\"2094\":[\"\",2089,\" \"],\"2095\":[\"\",2090,\" \"],\"2096\":[\"\",2091,\" \"],\"2097\":[\"\",2092,\" \"],\"2098\":[\"\",2093,\" \"],\"2099\":[\"\",2094,\" \"],\"2100\":[\"\",2095,\" \"],\"2101\":[\"\",2096,\" \"],\"2102\":[\"\",2097,\" \"],\"2103\":[\"\",2098,\" \"],\"2104\":[\"\",2099,\" \"],\"2105\":[\"\",2100,\" \"],\"2106\":[\"\",2101,\" \"],\"2107\":[\"\",2102,\" \"],\"2108\":[\"\",2103,\" \"],\"2109\":[\"\",2104,\" \"],\"2110\":[\"\",2105,\" \"],\"2111\":[\"\",2106,\" \"],\"2112\":[\"\",2107,\" \"],\"2113\":[\"\",2108,\" \"],\"2114\":[\"\",2109,\" \"],\"2115\":[\"\",2110,\" \"],\"2116\":[\"\",2111,\" \"],\"2117\":[\"\",2112,\" \"],\"2118\":[\"\",2113,\" \"],\"2119\":[\"\",2114,\" \"],\"2120\":[\"\",2115,\" \"],\"2121\":[\"\",2116,\" \"],\"2122\":[\"\",2117,\" \"],\"2123\":[\"\",2118,\" \"],\"2124\":[\"\",2119,\" \"],\"2125\":[\"\",2120,\" \"],\"2126\":[\"\",2121,\" \"],\"2127\":[\"\",2122,\" \"],\"2128\":[\"\",2123,\" \"],\"2129\":[\"\",2124,\" \"],\"2130\":[\"\",2125,\" \"],\"2131\":[\"\",2126,\" \"],\"2132\":[\"\",2127,\" \"],\"2133\":[\"\",2128,\" \"],\"2134\":[\"\",2129,\" \"],\"2135\":[\"\",2130,\" \"],\"2136\":[\"\",2131,\" \"],\"2137\":[\"\",2132,\" \"],\"2138\":[\"\",2133,\" \"],\"2139\":[\"\",2134,\" \"],\"2140\":[\"\",2135,\" \"],\"2141\":[\"\",2136,\" \"],\"2142\":[\"\",2137,\" \"],\"2143\":[\"\",2138,\" \"],\"2144\":[\"\",2139,\" \"],\"2145\":[\"\",2140,\" \"],\"2146\":[\"\",2141,\" \"],\"2147\":[\"\",2142,\" \"],\"2148\":[\"\",2143,\" \"],\"2149\":[\"\",2144,\" \"],\"2150\":[\"\",2145,\" \"],\"2151\":[\"\",2146,\" \"],\"2152\":[\"\",2147,\" \"],\"2153\":[\"\",2148,\" \"],\"2154\":[\"\",2149,\" \"],\"2155\":[\"\",2150,\" \"],\"2156\":[\"\",2151,\" \"],\"2157\":[\"\",2152,\" \"],\"2158\":[\"\",2153,\" \"],\"2159\":[\"\",2154,\" \"],\"2160\":[\"\",2155,\" \"],\"2161\":[\"\",2156,\" \"],\"2162\":[\"\",2157,\" \"],\"2163\":[\"\",2158,\" \"],\"2164\":[\"\",2159,\" \"],\"2165\":[\"\",2160,\" \"],\"2166\":[\"\",2161,\" \"],\"2167\":[\"\",2162,\" \"],\"2168\":[\"\",2163,\" \"],\"2169\":[\"\",2164,\" \"],\"2170\":[\"\",2165,\" \"],\"2171\":[\"\",2166,\" \"],\"2172\":[\"\",2167,\" \"],\"2173\":[\"\",2168,\" \"],\"2174\":[\"\",2169,\" \"],\"2175\":[\"\",2170,\" \"],\"2176\":[\"\",2171,\" \"],\"2177\":[\"\",2172,\" \"],\"2178\":[\"\",2173,\" \"],\"2179\":[\"\",2174,\" \"],\"2180\":[\"\",2175,\" \"],\"2181\":[\"\",2176,\" \"],\"2182\":[\"\",2177,\" \"],\"2183\":[\"\",2178,\" \"],\"2184\":[\"\",2179,\" \"],\"2185\":[\"\",2180,\" \"],\"2186\":[\"\",2181,\" \"],\"2187\":[\"\",2182,\" \"],\"2188\":[\"\",2183,\" \"],\"2189\":[\"\",2184,\" \"],\"2190\":[\"\",2185,\" \"],\"2191\":[\"\",2186,\" \"],\"2192\":[\"\",2187,\" \"],\"2193\":[\"\",2188,\" \"],\"2194\":[\"\",2189,\" \"],\"2195\":[\"\",2190,\" \"],\"2196\":[\"\",2191,\" \"],\"2197\":[\"\",2192,\" \"],\"2198\":[\"\",2193,\" \"],\"2199\":[\"\",2194,\" \"],\"2200\":[\"\",2195,\" \"],\"2201\":[\"\",2196,\" \"],\"2202\":[\"\",2197,\" \"],\"2203\":[\"\",2198,\" \"],\"2204\":[\"\",2199,\" \"],\"2205\":[\"\",2200,\" \"],\"2206\":[\"\",2201,\" \"],\"2207\":[\"\",2202,\" \"],\"2208\":[\"\",2203,\" \"],\"2209\":[\"\",2204,\" \"],\"2210\":[\"\",2205,\" \"],\"2211\":[\"\",2206,\" \"],\"2212\":[\"\",2207,\" \"],\"2213\":[\"\",2208,\" \"],\"2214\":[\"\",2209,\" \"],\"2215\":[\"\",2210,\" \"],\"2216\":[\"\",2211,\" \"],\"2217\":[\"\",2212,\" \"],\"2218\":[\"\",2213,\" \"],\"2219\":[\"\",2214,\" \"],\"2220\":[\"\",2215,\" \"],\"2221\":[\"\",2216,\" \"],\"2222\":[\"\",2217,\" \"],\"2223\":[\"\",2218,\" \"],\"2224\":[\"\",2219,\" \"],\"2225\":[\"\",2220,\" \"],\"2226\":[\"\",2221,\" \"],\"2227\":[\"\",2222,\" \"],\"2228\":[\"\",2223,\" \"],\"2229\":[\"\",2224,\" \"],\"2230\":[\"\",2225,\" \"],\"2231\":[\"\",2226,\" \"],\"2232\":[\"\",2227,\" \"],\"2233\":[\"\",2228,\" \"],\"2234\":[\"\",2229,\" \"],\"2235\":[\"\",2230,\" \"],\"2236\":[\"\",2231,\" \"],\"2237\":[\"\",2232,\" \"],\"2238\":[\"\",2233,\" \"],\"2239\":[\"\",2234,\" \"],\"2240\":[\"\",2235,\" \"],\"2241\":[\"\",2236,\" \"],\"2242\":[\"\",2237,\" \"],\"2243\":[\"\",2238,\" \"],\"2244\":[\"\",2239,\" \"],\"2245\":[\"\",2240,\" \"],\"2246\":[\"\",2241,\" \"],\"2247\":[\"\",2242,\" \"],\"2248\":[\"\",2243,\" \"],\"2249\":[\"\",2244,\" \"],\"2250\":[\"\",2245,\" \"],\"2251\":[\"\",2246,\" \"],\"2252\":[\"\",2247,\" \"],\"2253\":[\"\",2248,\" \"],\"2254\":[\"\",2249,\" \"],\"2255\":[\"\",2250,\" \"],\"2256\":[\"\",2251,\" \"],\"2257\":[\"\",2252,\" \"],\"2258\":[\"\",2253,\" \"],\"2259\":[\"\",2254,\" \"],\"2260\":[\"\",2255,\" \"],\"2261\":[\"\",2256,\" \"],\"2262\":[\"\",2257,\" \"],\"2263\":[\"\",2258,\" \"],\"2264\":[\"\",2259,\" \"],\"2265\":[\"\",2260,\" \"],\"2266\":[\"\",2261,\" \"],\"2267\":[\"\",2262,\" \"],\"2268\":[\"\",2263,\" \"],\"2269\":[\"\",2264,\" \"],\"2270\":[\"\",2265,\" \"],\"2271\":[\"\",2266,\" \"],\"2272\":[\"\",2267,\" \"],\"2273\":[\"\",2268,\" \"],\"2274\":[\"\",2269,\" \"],\"2275\":[\"\",2270,\" \"],\"2276\":[\"\",2271,\" \"],\"2277\":[\"\",2272,\" \"],\"2278\":[\"\",2273,\" \"],\"2279\":[\"\",2274,\" \"],\"2280\":[\"\",2275,\" \"],\"2281\":[\"\",2276,\" \"],\"2282\":[\"\",2277,\" \"],\"2283\":[\"\",2278,\" \"],\"2284\":[\"\",2279,\" \"],\"2285\":[\"\",2280,\" \"],\"2286\":[\"\",2281,\" \"],\"2287\":[\"\",2282,\" \"],\"2288\":[\"\",2283,\" \"],\"2289\":[\"\",2284,\" \"],\"2290\":[\"\",2285,\" \"],\"2291\":[\"\",2286,\" \"],\"2292\":[\"\",2287,\" \"],\"2293\":[\"\",2288,\" \"],\"2294\":[\"\",2289,\" \"],\"2295\":[\"\",2290,\" \"],\"2296\":[\"\",2291,\" \"],\"2297\":[\"\",2292,\" \"],\"2298\":[\"\",2293,\" \"],\"2299\":[\"\",2294,\" \"],\"2300\":[\"\",2295,\" \"],\"2301\":[\"\",2296,\" \"],\"2302\":[\"\",2297,\" \"],\"2303\":[\"\",2298,\" \"],\"2304\":[\"\",2299,\" \"],\"2305\":[\"\",2300,\" \"],\"2306\":[\"\",2301,\" \"],\"2307\":[\"\",2302,\" \"],\"2308\":[\"\",2303,\" \"],\"2309\":[\"\",2304,\" \"],\"2310\":[\"\",2305,\" \"],\"2311\":[\"\",2306,\" \"],\"2312\":[\"\",2307,\" \"],\"2313\":[\"\",2308,\" \"],\"2314\":[\"\",2309,\" \"],\"2315\":[\"\",2310,\" \"],\"2316\":[\"\",2311,\" \"],\"2317\":[\"\",2312,\" \"],\"2318\":[\"\",2313,\" \"],\"2319\":[\"\",2314,\" \"],\"2320\":[\"\",2315,\" \"],\"2321\":[\"\",2316,\" \"],\"2322\":[\"\",2317,\" \"],\"2323\":[\"\",2318,\" \"],\"2324\":[\"\",2319,\" \"],\"2325\":[\"\",2320,\" \"],\"2326\":[\"\",2321,\" \"],\"2327\":[\"\",2322,\" \"],\"2328\":[\"\",2323,\" \"],\"2329\":[\"\",2324,\" \"],\"2330\":[\"\",2325,\" \"],\"2331\":[\"\",2326,\" \"],\"2332\":[\"\",2327,\" \"],\"2333\":[\"\",2328,\" \"],\"2334\":[\"\",2329,\" \"],\"2335\":[\"\",2330,\" \"],\"2336\":[\"\",2331,\" \"],\"2337\":[\"\",2332,\" \"],\"2338\":[\"\",2333,\" \"],\"2339\":[\"\",2334,\" \"],\"2340\":[\"\",2335,\" \"],\"2341\":[\"\",2336,\" \"],\"2342\":[\"\",2337,\" \"],\"2343\":[\"\",2338,\" \"],\"2344\":[\"\",2339,\" \"],\"2345\":[\"\",2340,\" \"],\"2346\":[\"\",2341,\" \"],\"2347\":[\"\",2342,\" \"],\"2348\":[\"\",2343,\" \"],\"2349\":[\"\",2344,\" \"],\"2350\":[\"\",2345,\" \"],\"2351\":[\"\",2346,\" \"],\"2352\":[\"\",2347,\" \"],\"2353\":[\"\",2348,\" \"],\"2354\":[\"\",2349,\" \"],\"2355\":[\"\",2350,\" \"],\"2356\":[\"\",2351,\" \"],\"2357\":[\"\",2352,\" \"],\"2358\":[\"\",2353,\" \"],\"2359\":[\"\",2354,\" \"],\"2360\":[\"\",2355,\" \"],\"2361\":[\"\",2356,\" \"],\"2362\":[\"\",2357,\" \"],\"2363\":[\"\",2358,\" \"],\"2364\":[\"\",2359,\" \"],\"2365\":[\"\",2360,\" \"],\"2366\":[\"\",2361,\" \"],\"2367\":[\"\",2362,\" \"],\"2368\":[\"\",2363,\" \"],\"2369\":[\"\",2364,\" \"],\"2370\":[\"\",2365,\" \"],\"2371\":[\"\",2366,\" \"],\"2372\":[\"\",2367,\" \"],\"2373\":[\"\",2368,\" \"],\"2374\":[\"\",2369,\" \"],\"2375\":[\"\",2370,\" \"],\"2376\":[\"\",2371,\" \"],\"2377\":[\"\",2372,\" \"],\"2378\":[\"\",2373,\" \"],\"2379\":[\"\",2374,\" \"],\"2380\":[\"\",2375,\" \"],\"2381\":[\"\",2376,\" \"],\"2382\":[\"\",2377,\" \"],\"2383\":[\"\",2378,\" \"],\"2384\":[\"\",2379,\" \"],\"2385\":[\"\",2380,\" \"],\"2386\":[\"\",2381,\" \"],\"2387\":[\"\",2382,\" \"],\"2388\":[\"\",2383,\" \"],\"2389\":[\"\",2384,\" \"],\"2390\":[\"\",2385,\" \"],\"2391\":[\"\",2386,\" \"],\"2392\":[\"\",2387,\" \"],\"2393\":[\"\",2388,\" \"],\"2394\":[\"\",2389,\" \"],\"2395\":[\"\",2390,\" \"],\"2396\":[\"\",2391,\" \"],\"2397\":[\"\",2392,\" \"],\"2398\":[\"\",2393,\" \"],\"2399\":[\"\",2394,\" \"],\"2400\":[\"\",2395,\" \"],\"2401\":[\"\",2396,\" \"],\"2402\":[\"\",2397,\" \"],\"2403\":[\"\",2398,\" \"],\"2404\":[\"\",2399,\" \"],\"2405\":[\"\",2400,\" \"],\"2406\":[\"\",2401,\" \"],\"2407\":[\"\",2402,\" \"],\"2408\":[\"\",2403,\" \"],\"2409\":[\"\",2404,\" \"],\"2410\":[\"\",2405,\" \"],\"2411\":[\"\",2406,\" \"],\"2412\":[\"\",2407,\" \"],\"2413\":[\"\",2408,\" \"],\"2414\":[\"\",2409,\" \"],\"2415\":[\"\",2410,\" \"],\"2416\":[\"\",2411,\" \"],\"2417\":[\"\",2412,\" \"],\"2418\":[\"\",2413,\" \"],\"2419\":[\"\",2414,\" \"],\"2420\":[\"\",2415,\" \"],\"2421\":[\"\",2416,\" \"],\"2422\":[\"\",2417,\" \"],\"2423\":[\"\",2418,\" \"],\"2424\":[\"\",2419,\" \"],\"2425\":[\"\",2420,\" \"],\"2426\":[\"\",2421,\" \"],\"2427\":[\"\",2422,\" \"],\"2428\":[\"\",2423,\" \"],\"2429\":[\"\",2424,\" \"],\"2430\":[\"\",2425,\" \"],\"2431\":[\"\",2426,\" \"],\"2432\":[\"\",2427,\" \"],\"2433\":[\"\",2428,\" \"],\"2434\":[\"\",2429,\" \"],\"2435\":[\"\",2430,\" \"],\"2436\":[\"\",2431,\" \"],\"2437\":[\"\",2432,\" \"],\"2438\":[\"\",2433,\" \"],\"2439\":[\"\",2434,\" \"],\"2440\":[\"\",2435,\" \"],\"2441\":[\"\",2436,\" \"],\"2442\":[\"\",2437,\" \"],\"2443\":[\"\",2438,\" \"],\"2444\":[\"\",2439,\" \"],\"2445\":[\"\",2440,\" \"],\"2446\":[\"\",2441,\" \"],\"2447\":[\"\",2442,\" \"],\"2448\":[\"\",2443,\" \"],\"2449\":[\"\",2444,\" \"],\"2450\":[\"\",2445,\" \"],\"2451\":[\"\",2446,\" \"],\"2452\":[\"\",2447,\" \"],\"2453\":[\"\",2448,\" \"],\"2454\":[\"\",2449,\" \"],\"2455\":[\"\",2450,\" \"],\"2456\":[\"\",2451,\" \"],\"2457\":[\"\",2452,\" \"],\"2458\":[\"\",2453,\" \"],\"2459\":[\"\",2454,\" \"],\"2460\":[\"\",2455,\" \"],\"2461\":[\"\",2456,\" \"],\"2462\":[\"\",2457,\" \"],\"2463\":[\"\",2458,\" \"],\"2464\":[\"\",2459,\" \"],\"2465\":[\"\",2460,\" \"],\"2466\":[\"\",2461,\" \"],\"2467\":[\"\",2462,\" \"],\"2468\":[\"\",2463,\" \"],\"2469\":[\"\",2464,\" \"],\"2470\":[\"\",2465,\" \"],\"2471\":[\"\",2466,\" \"],\"2472\":[\"\",2467,\" \"],\"2473\":[\"\",2468,\" \"],\"2474\":[\"\",2469,\" \"],\"2475\":[\"\",2470,\" \"],\"2476\":[\"\",2471,\" \"],\"2477\":[\"\",2472,\" \"],\"2478\":[\"\",2473,\" \"],\"2479\":[\"\",2474,\" \"],\"2480\":[\"\",2475,\" \"],\"2481\":[\"\",2476,\" \"],\"2482\":[\"\",2477,\" \"],\"2483\":[\"\",2478,\" \"],\"2484\":[\"\",2479,\" \"],\"2485\":[\"\",2480,\" \"],\"2486\":[\"\",2481,\" \"],\"2487\":[\"\",2482,\" \"],\"2488\":[\"\",2483,\" \"],\"2489\":[\"\",2484,\" \"],\"2490\":[\"\",2485,\" \"],\"2491\":[\"\",2486,\" \"],\"2492\":[\"\",2487,\" \"],\"2493\":[\"\",2488,\" \"],\"2494\":[\"\",2489,\" \"],\"2495\":[\"\",2490,\" \"],\"2496\":[\"\",2491,\" \"],\"2497\":[\"\",2492,\" \"],\"2498\":[\"\",2493,\" \"],\"2499\":[\"\",2494,\" \"],\"2500\":[\"\",2495,\" \"],\"2501\":[\"\",2496,\" \"],\"2502\":[\"\",2497,\" \"],\"2503\":[\"\",2498,\" \"],\"2504\":[\"\",2499,\" \"],\"2505\":[\"\",2500,\" \"],\"2506\":[\"\",2501,\" \"],\"2507\":[\"\",2502,\" \"],\"2508\":[\"\",2503,\" \"],\"2509\":[\"\",2504,\" \"],\"2510\":[\"\",2505,\" \"],\"2511\":[\"\",2506,\" \"],\"2512\":[\"\",2507,\" \"],\"2513\":[\"\",2508,\" \"],\"2514\":[\"\",2509,\" \"],\"2515\":[\"\",2510,\" \"],\"2516\":[\"\",2511,\" \"],\"2517\":[\"\",2512,\" \"],\"2518\":[\"\",2513,\" \"],\"2519\":[\"\",2514,\" \"],\"2520\":[\"\",2515,\" \"],\"2521\":[\"\",2516,\" \"],\"2522\":[\"\",2517,\" \"],\"2523\":[\"\",2518,\" \"],\"2524\":[\"\",2519,\" \"],\"2525\":[\"\",2520,\" \"],\"2526\":[\"\",2521,\" \"],\"2527\":[\"\",2522,\" \"],\"2528\":[\"\",2523,\" \"],\"2529\":[\"\",2524,\" \"],\"2530\":[\"\",2525,\" \"],\"2531\":[\"\",2526,\" \"],\"2532\":[\"\",2527,\" \"],\"2533\":[\"\",2528,\" \"],\"2534\":[\"\",2529,\" \"],\"2535\":[\"\",2530,\" \"],\"2536\":[\"\",2531,\" \"],\"2537\":[\"\",2532,\" \"],\"2538\":[\"\",2533,\" \"],\"2539\":[\"\",2534,\" \"],\"2540\":[\"\",2535,\" \"],\"2541\":[\"\",2536,\" \"],\"2542\":[\"\",2537,\" \"],\"2543\":[\"\",2538,\" \"],\"2544\":[\"\",2539,\" \"],\"2545\":[\"\",2540,\" \"],\"2546\":[\"\",2541,\" \"],\"2547\":[\"\",2542,\" \"],\"2548\":[\"\",2543,\" \"],\"2549\":[\"\",2544,\" \"],\"2550\":[\"\",2545,\" \"],\"2551\":[\"\",2546,\" \"],\"2552\":[\"\",2547,\" \"],\"2553\":[\"\",2548,\" \"],\"2554\":[\"\",2549,\" \"],\"2555\":[\"\",2550,\" \"],\"2556\":[\"\",2551,\" \"],\"2557\":[\"\",2552,\" \"],\"2558\":[\"\",2553,\" \"],\"2559\":[\"\",2554,\" \"],\"2560\":[\"\",2555,\" \"],\"2561\":[\"\",2556,\" \"],\"2562\":[\"\",2557,\" \"],\"2563\":[\"\",2558,\" \"],\"2564\":[\"\",2559,\" \"],\"2565\":[\"\",2560,\" \"],\"2566\":[\"\",2561,\" \"],\"2567\":[\"\",2562,\" \"],\"2568\":[\"\",2563,\" \"],\"2569\":[\"\",2564,\" \"],\"2570\":[\"\",2565,\" \"],\"2571\":[\"\",2566,\" \"],\"2572\":[\"\",2567,\" \"],\"2573\":[\"\",2568,\" \"],\"2574\":[\"\",2569,\" \"],\"2575\":[\"\",2570,\" \"],\"2576\":[\"\",2571,\" \"],\"2577\":[\"\",2572,\" \"],\"2578\":[\"\",2573,\" \"],\"2579\":[\"\",2574,\" \"],\"2580\":[\"\",2575,\" \"],\"2581\":[\"\",2576,\" \"],\"2582\":[\"\",2577,\" \"],\"2583\":[\"\",2578,\" \"],\"2584\":[\"\",2579,\" \"],\"2585\":[\"\",2580,\" \"],\"2586\":[\"\",2581,\" \"],\"2587\":[\"\",2582,\" \"],\"2588\":[\"\",2583,\" \"],\"2589\":[\"\",2584,\" \"],\"2590\":[\"\",2585,\" \"],\"2591\":[\"\",2586,\" \"],\"2592\":[\"\",2587,\" \"],\"2593\":[\"\",2588,\" \"],\"2594\":[\"\",2589,\" \"],\"2595\":[\"\",2590,\" \"],\"2596\":[\"\",2591,\" \"],\"2597\":[\"\",2592,\" \"],\"2598\":[\"\",2593,\" \"],\"2599\":[\"\",2594,\" \"],\"2600\":[\"\",2595,\" \"],\"2601\":[\"\",2596,\" \"],\"2602\":[\"\",2597,\" \"],\"2603\":[\"\",2598,\" \"],\"2604\":[\"\",2599,\" \"],\"2605\":[\"\",2600,\" \"],\"2606\":[\"\",2601,\" \"],\"2607\":[\"\",2602,\" \"],\"2608\":[\"\",2603,\" \"],\"2609\":[\"\",2604,\" \"],\"2610\":[\"\",2605,\" \"],\"2611\":[\"\",2606,\" \"],\"2612\":[\"\",2607,\" \"],\"2613\":[\"\",2608,\" \"],\"2614\":[\"\",2609,\" \"],\"2615\":[\"\",2610,\" \"],\"2616\":[\"\",2611,\" \"],\"2617\":[\"\",2612,\" \"],\"2618\":[\"\",2613,\" \"],\"2619\":[\"\",2614,\" \"],\"2620\":[\"\",2615,\" \"],\"2621\":[\"\",2616,\" \"],\"2622\":[\"\",2617,\" \"],\"2623\":[\"\",2618,\" \"],\"2624\":[\"\",2619,\" \"],\"2625\":[\"\",2620,\" \"],\"2626\":[\"\",2621,\" \"],\"2627\":[\"\",2622,\" \"],\"2628\":[\"\",2623,\" \"],\"2629\":[\"\",2624,\" \"],\"2630\":[\"\",2625,\" \"],\"2631\":[\"\",2626,\" \"],\"2632\":[\"\",2627,\" \"],\"2633\":[\"\",2628,\" \"],\"2634\":[\"\",2629,\" \"],\"2635\":[\"\",2630,\" \"],\"2636\":[\"\",2631,\" \"],\"2637\":[\"\",2632,\" \"],\"2638\":[\"\",2633,\" \"],\"2639\":[\"\",2634,\" \"],\"2640\":[\"\",2635,\" \"],\"2641\":[\"\",2636,\" \"],\"2642\":[\"\",2637,\" \"],\"2643\":[\"\",2638,\" \"],\"2644\":[\"\",2639,\" \"],\"2645\":[\"\",2640,\" \"],\"2646\":[\"\",2641,\" \"],\"2647\":[\"\",2642,\" \"],\"2648\":[\"\",2643,\" \"],\"2649\":[\"\",2644,\" \"]}},\"oldPath\":\"mercurial\\/exchange.py\",\"currentPath\":\"mercurial\\/exchange.py\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":[],\"type\":\"2\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"16\",\"delLines\":\"11\",\"hunks\":[{\"oldOffset\":\"1\",\"newOffset\":\"1\",\"oldLength\":\"2644\",\"newLength\":\"2649\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\" # exchange.py - utility to exchange data between repos.\\n #\\n # Copyright 2005-2007 Matt Mackall \\u003cmpm@selenic.com\\u003e\\n #\\n # This software may be used and distributed according to the terms of the\\n # GNU General Public License version 2 or any later version.\\n \\n from __future__ import absolute_import\\n \\n import collections\\n import hashlib\\n \\n from .i18n import _\\n from .node import (\\n     bin,\\n     hex,\\n     nullid,\\n     nullrev,\\n )\\n from .thirdparty import (\\n     attr,\\n )\\n from . import (\\n     bookmarks as bookmod,\\n     bundle2,\\n     changegroup,\\n     discovery,\\n     error,\\n+    exchangev2,\\n     lock as lockmod,\\n     logexchange,\\n     narrowspec,\\n     obsolete,\\n     phases,\\n     pushkey,\\n     pycompat,\\n     repository,\\n     scmutil,\\n     sslutil,\\n     streamclone,\\n     url as urlmod,\\n     util,\\n )\\n from .utils import (\\n     stringutil,\\n )\\n \\n urlerr = util.urlerr\\n urlreq = util.urlreq\\n \\n _NARROWACL_SECTION = 'narrowhgacl'\\n \\n # Maps bundle version human names to changegroup versions.\\n _bundlespeccgversions = {'v1': '01',\\n                          'v2': '02',\\n                          'packed1': 's1',\\n                          'bundle2': '02', #legacy\\n                         }\\n \\n # Maps bundle version with content opts to choose which part to bundle\\n _bundlespeccontentopts = {\\n     'v1': {\\n         'changegroup': True,\\n         'cg.version': '01',\\n         'obsolescence': False,\\n         'phases': False,\\n         'tagsfnodescache': False,\\n         'revbranchcache': False\\n     },\\n     'v2': {\\n         'changegroup': True,\\n         'cg.version': '02',\\n         'obsolescence': False,\\n         'phases': False,\\n         'tagsfnodescache': True,\\n         'revbranchcache': True\\n     },\\n     'packed1' : {\\n         'cg.version': 's1'\\n     }\\n }\\n _bundlespeccontentopts['bundle2'] = _bundlespeccontentopts['v2']\\n \\n _bundlespecvariants = {\\\"streamv2\\\": {\\\"changegroup\\\": False, \\\"streamv2\\\": True,\\n                                     \\\"tagsfnodescache\\\": False,\\n                                     \\\"revbranchcache\\\": False}}\\n \\n # Compression engines allowed in version 1. THIS SHOULD NEVER CHANGE.\\n _bundlespecv1compengines = {'gzip', 'bzip2', 'none'}\\n \\n @attr.s\\n class bundlespec(object):\\n     compression = attr.ib()\\n     wirecompression = attr.ib()\\n     version = attr.ib()\\n     wireversion = attr.ib()\\n     params = attr.ib()\\n     contentopts = attr.ib()\\n \\n def parsebundlespec(repo, spec, strict=True):\\n     \\\"\\\"\\\"Parse a bundle string specification into parts.\\n \\n     Bundle specifications denote a well-defined bundle\\/exchange format.\\n     The content of a given specification should not change over time in\\n     order to ensure that bundles produced by a newer version of Mercurial are\\n     readable from an older version.\\n \\n     The string currently has the form:\\n \\n        \\u003ccompression\\u003e-\\u003ctype\\u003e[;\\u003cparameter0\\u003e[;\\u003cparameter1\\u003e]]\\n \\n     Where \\u003ccompression\\u003e is one of the supported compression formats\\n     and \\u003ctype\\u003e is (currently) a version string. A \\\";\\\" can follow the type and\\n     all text afterwards is interpreted as URI encoded, \\\";\\\" delimited key=value\\n     pairs.\\n \\n     If ``strict`` is True (the default) \\u003ccompression\\u003e is required. Otherwise,\\n     it is optional.\\n \\n     Returns a bundlespec object of (compression, version, parameters).\\n     Compression will be ``None`` if not in strict mode and a compression isn't\\n     defined.\\n \\n     An ``InvalidBundleSpecification`` is raised when the specification is\\n     not syntactically well formed.\\n \\n     An ``UnsupportedBundleSpecification`` is raised when the compression or\\n     bundle type\\/version is not recognized.\\n \\n     Note: this function will likely eventually return a more complex data\\n     structure, including bundle2 part information.\\n     \\\"\\\"\\\"\\n     def parseparams(s):\\n         if ';' not in s:\\n             return s, {}\\n \\n         params = {}\\n         version, paramstr = s.split(';', 1)\\n \\n         for p in paramstr.split(';'):\\n             if '=' not in p:\\n                 raise error.InvalidBundleSpecification(\\n                     _('invalid bundle specification: '\\n                       'missing \\\"=\\\" in parameter: %s') % p)\\n \\n             key, value = p.split('=', 1)\\n             key = urlreq.unquote(key)\\n             value = urlreq.unquote(value)\\n             params[key] = value\\n \\n         return version, params\\n \\n \\n     if strict and '-' not in spec:\\n         raise error.InvalidBundleSpecification(\\n                 _('invalid bundle specification; '\\n                   'must be prefixed with compression: %s') % spec)\\n \\n     if '-' in spec:\\n         compression, version = spec.split('-', 1)\\n \\n         if compression not in util.compengines.supportedbundlenames:\\n             raise error.UnsupportedBundleSpecification(\\n                     _('%s compression is not supported') % compression)\\n \\n         version, params = parseparams(version)\\n \\n         if version not in _bundlespeccgversions:\\n             raise error.UnsupportedBundleSpecification(\\n                     _('%s is not a recognized bundle version') % version)\\n     else:\\n         # Value could be just the compression or just the version, in which\\n         # case some defaults are assumed (but only when not in strict mode).\\n         assert not strict\\n \\n         spec, params = parseparams(spec)\\n \\n         if spec in util.compengines.supportedbundlenames:\\n             compression = spec\\n             version = 'v1'\\n             # Generaldelta repos require v2.\\n             if 'generaldelta' in repo.requirements:\\n                 version = 'v2'\\n             # Modern compression engines require v2.\\n             if compression not in _bundlespecv1compengines:\\n                 version = 'v2'\\n         elif spec in _bundlespeccgversions:\\n             if spec == 'packed1':\\n                 compression = 'none'\\n             else:\\n                 compression = 'bzip2'\\n             version = spec\\n         else:\\n             raise error.UnsupportedBundleSpecification(\\n                     _('%s is not a recognized bundle specification') % spec)\\n \\n     # Bundle version 1 only supports a known set of compression engines.\\n     if version == 'v1' and compression not in _bundlespecv1compengines:\\n         raise error.UnsupportedBundleSpecification(\\n             _('compression engine %s is not supported on v1 bundles') %\\n             compression)\\n \\n     # The specification for packed1 can optionally declare the data formats\\n     # required to apply it. If we see this metadata, compare against what the\\n     # repo supports and error if the bundle isn't compatible.\\n     if version == 'packed1' and 'requirements' in params:\\n         requirements = set(params['requirements'].split(','))\\n         missingreqs = requirements - repo.supportedformats\\n         if missingreqs:\\n             raise error.UnsupportedBundleSpecification(\\n                     _('missing support for repository features: %s') %\\n                       ', '.join(sorted(missingreqs)))\\n \\n     # Compute contentopts based on the version\\n     contentopts = _bundlespeccontentopts.get(version, {}).copy()\\n \\n     # Process the variants\\n     if \\\"stream\\\" in params and params[\\\"stream\\\"] == \\\"v2\\\":\\n         variant = _bundlespecvariants[\\\"streamv2\\\"]\\n         contentopts.update(variant)\\n \\n     engine = util.compengines.forbundlename(compression)\\n     compression, wirecompression = engine.bundletype()\\n     wireversion = _bundlespeccgversions[version]\\n \\n     return bundlespec(compression, wirecompression, version, wireversion,\\n                       params, contentopts)\\n \\n def readbundle(ui, fh, fname, vfs=None):\\n     header = changegroup.readexactly(fh, 4)\\n \\n     alg = None\\n     if not fname:\\n         fname = \\\"stream\\\"\\n         if not header.startswith('HG') and header.startswith('\\\\0'):\\n             fh = changegroup.headerlessfixup(fh, header)\\n             header = \\\"HG10\\\"\\n             alg = 'UN'\\n     elif vfs:\\n         fname = vfs.join(fname)\\n \\n     magic, version = header[0:2], header[2:4]\\n \\n     if magic != 'HG':\\n         raise error.Abort(_('%s: not a Mercurial bundle') % fname)\\n     if version == '10':\\n         if alg is None:\\n             alg = changegroup.readexactly(fh, 2)\\n         return changegroup.cg1unpacker(fh, alg)\\n     elif version.startswith('2'):\\n         return bundle2.getunbundler(ui, fh, magicstring=magic + version)\\n     elif version == 'S1':\\n         return streamclone.streamcloneapplier(fh)\\n     else:\\n         raise error.Abort(_('%s: unknown bundle version %s') % (fname, version))\\n \\n def getbundlespec(ui, fh):\\n     \\\"\\\"\\\"Infer the bundlespec from a bundle file handle.\\n \\n     The input file handle is seeked and the original seek position is not\\n     restored.\\n     \\\"\\\"\\\"\\n     def speccompression(alg):\\n         try:\\n             return util.compengines.forbundletype(alg).bundletype()[0]\\n         except KeyError:\\n             return None\\n \\n     b = readbundle(ui, fh, None)\\n     if isinstance(b, changegroup.cg1unpacker):\\n         alg = b._type\\n         if alg == '_truncatedBZ':\\n             alg = 'BZ'\\n         comp = speccompression(alg)\\n         if not comp:\\n             raise error.Abort(_('unknown compression algorithm: %s') % alg)\\n         return '%s-v1' % comp\\n     elif isinstance(b, bundle2.unbundle20):\\n         if 'Compression' in b.params:\\n             comp = speccompression(b.params['Compression'])\\n             if not comp:\\n                 raise error.Abort(_('unknown compression algorithm: %s') % comp)\\n         else:\\n             comp = 'none'\\n \\n         version = None\\n         for part in b.iterparts():\\n             if part.type == 'changegroup':\\n                 version = part.params['version']\\n                 if version in ('01', '02'):\\n                     version = 'v2'\\n                 else:\\n                     raise error.Abort(_('changegroup version %s does not have '\\n                                         'a known bundlespec') % version,\\n                                       hint=_('try upgrading your Mercurial '\\n                                               'client'))\\n             elif part.type == 'stream2' and version is None:\\n                 # A stream2 part requires to be part of a v2 bundle\\n                 version = \\\"v2\\\"\\n                 requirements = urlreq.unquote(part.params['requirements'])\\n                 splitted = requirements.split()\\n                 params = bundle2._formatrequirementsparams(splitted)\\n                 return 'none-v2;stream=v2;%s' % params\\n \\n         if not version:\\n             raise error.Abort(_('could not identify changegroup version in '\\n                                 'bundle'))\\n \\n         return '%s-%s' % (comp, version)\\n     elif isinstance(b, streamclone.streamcloneapplier):\\n         requirements = streamclone.readbundle1header(fh)[2]\\n         formatted = bundle2._formatrequirementsparams(requirements)\\n         return 'none-packed1;%s' % formatted\\n     else:\\n         raise error.Abort(_('unknown bundle type: %s') % b)\\n \\n def _computeoutgoing(repo, heads, common):\\n     \\\"\\\"\\\"Computes which revs are outgoing given a set of common\\n     and a set of heads.\\n \\n     This is a separate function so extensions can have access to\\n     the logic.\\n \\n     Returns a discovery.outgoing object.\\n     \\\"\\\"\\\"\\n     cl = repo.changelog\\n     if common:\\n         hasnode = cl.hasnode\\n         common = [n for n in common if hasnode(n)]\\n     else:\\n         common = [nullid]\\n     if not heads:\\n         heads = cl.heads()\\n     return discovery.outgoing(repo, common, heads)\\n \\n def _forcebundle1(op):\\n     \\\"\\\"\\\"return true if a pull\\/push must use bundle1\\n \\n     This function is used to allow testing of the older bundle version\\\"\\\"\\\"\\n     ui = op.repo.ui\\n     # The goal is this config is to allow developer to choose the bundle\\n     # version used during exchanged. This is especially handy during test.\\n     # Value is a list of bundle version to be picked from, highest version\\n     # should be used.\\n     #\\n     # developer config: devel.legacy.exchange\\n     exchange = ui.configlist('devel', 'legacy.exchange')\\n     forcebundle1 = 'bundle2' not in exchange and 'bundle1' in exchange\\n     return forcebundle1 or not op.remote.capable('bundle2')\\n \\n class pushoperation(object):\\n     \\\"\\\"\\\"A object that represent a single push operation\\n \\n     Its purpose is to carry push related state and very common operations.\\n \\n     A new pushoperation should be created at the beginning of each push and\\n     discarded afterward.\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, repo, remote, force=False, revs=None, newbranch=False,\\n                  bookmarks=(), pushvars=None):\\n         # repo we push from\\n         self.repo = repo\\n         self.ui = repo.ui\\n         # repo we push to\\n         self.remote = remote\\n         # force option provided\\n         self.force = force\\n         # revs to be pushed (None is \\\"all\\\")\\n         self.revs = revs\\n         # bookmark explicitly pushed\\n         self.bookmarks = bookmarks\\n         # allow push of new branch\\n         self.newbranch = newbranch\\n         # step already performed\\n         # (used to check what steps have been already performed through bundle2)\\n         self.stepsdone = set()\\n         # Integer version of the changegroup push result\\n         # - None means nothing to push\\n         # - 0 means HTTP error\\n         # - 1 means we pushed and remote head count is unchanged *or*\\n         #   we have outgoing changesets but refused to push\\n         # - other values as described by addchangegroup()\\n         self.cgresult = None\\n         # Boolean value for the bookmark push\\n         self.bkresult = None\\n         # discover.outgoing object (contains common and outgoing data)\\n         self.outgoing = None\\n         # all remote topological heads before the push\\n         self.remoteheads = None\\n         # Details of the remote branch pre and post push\\n         #\\n         # mapping: {'branch': ([remoteheads],\\n         #                      [newheads],\\n         #                      [unsyncedheads],\\n         #                      [discardedheads])}\\n         # - branch: the branch name\\n         # - remoteheads: the list of remote heads known locally\\n         #                None if the branch is new\\n         # - newheads: the new remote heads (known locally) with outgoing pushed\\n         # - unsyncedheads: the list of remote heads unknown locally.\\n         # - discardedheads: the list of remote heads made obsolete by the push\\n         self.pushbranchmap = None\\n         # testable as a boolean indicating if any nodes are missing locally.\\n         self.incoming = None\\n         # summary of the remote phase situation\\n         self.remotephases = None\\n         # phases changes that must be pushed along side the changesets\\n         self.outdatedphases = None\\n         # phases changes that must be pushed if changeset push fails\\n         self.fallbackoutdatedphases = None\\n         # outgoing obsmarkers\\n         self.outobsmarkers = set()\\n         # outgoing bookmarks\\n         self.outbookmarks = []\\n         # transaction manager\\n         self.trmanager = None\\n         # map { pushkey partid -\\u003e callback handling failure}\\n         # used to handle exception from mandatory pushkey part failure\\n         self.pkfailcb = {}\\n         # an iterable of pushvars or None\\n         self.pushvars = pushvars\\n \\n     @util.propertycache\\n     def futureheads(self):\\n         \\\"\\\"\\\"future remote heads if the changeset push succeeds\\\"\\\"\\\"\\n         return self.outgoing.missingheads\\n \\n     @util.propertycache\\n     def fallbackheads(self):\\n         \\\"\\\"\\\"future remote heads if the changeset push fails\\\"\\\"\\\"\\n         if self.revs is None:\\n             # not target to push, all common are relevant\\n             return self.outgoing.commonheads\\n         unfi = self.repo.unfiltered()\\n         # I want cheads = heads(::missingheads and ::commonheads)\\n         # (missingheads is revs with secret changeset filtered out)\\n         #\\n         # This can be expressed as:\\n         #     cheads = ( (missingheads and ::commonheads)\\n         #              + (commonheads and ::missingheads))\\\"\\n         #              )\\n         #\\n         # while trying to push we already computed the following:\\n         #     common = (::commonheads)\\n         #     missing = ((commonheads::missingheads) - commonheads)\\n         #\\n         # We can pick:\\n         # * missingheads part of common (::commonheads)\\n         common = self.outgoing.common\\n         nm = self.repo.changelog.nodemap\\n         cheads = [node for node in self.revs if nm[node] in common]\\n         # and\\n         # * commonheads parents on missing\\n         revset = unfi.set('%ln and parents(roots(%ln))',\\n                          self.outgoing.commonheads,\\n                          self.outgoing.missing)\\n         cheads.extend(c.node() for c in revset)\\n         return cheads\\n \\n     @property\\n     def commonheads(self):\\n         \\\"\\\"\\\"set of all common heads after changeset bundle push\\\"\\\"\\\"\\n         if self.cgresult:\\n             return self.futureheads\\n         else:\\n             return self.fallbackheads\\n \\n # mapping of message used when pushing bookmark\\n bookmsgmap = {'update': (_(\\\"updating bookmark %s\\\\n\\\"),\\n                          _('updating bookmark %s failed!\\\\n')),\\n               'export': (_(\\\"exporting bookmark %s\\\\n\\\"),\\n                          _('exporting bookmark %s failed!\\\\n')),\\n               'delete': (_(\\\"deleting remote bookmark %s\\\\n\\\"),\\n                          _('deleting remote bookmark %s failed!\\\\n')),\\n               }\\n \\n \\n def push(repo, remote, force=False, revs=None, newbranch=False, bookmarks=(),\\n          opargs=None):\\n     '''Push outgoing changesets (limited by revs) from a local\\n     repository to remote. Return an integer:\\n       - None means nothing to push\\n       - 0 means HTTP error\\n       - 1 means we pushed and remote head count is unchanged *or*\\n         we have outgoing changesets but refused to push\\n       - other values as described by addchangegroup()\\n     '''\\n     if opargs is None:\\n         opargs = {}\\n     pushop = pushoperation(repo, remote, force, revs, newbranch, bookmarks,\\n                            **pycompat.strkwargs(opargs))\\n     if pushop.remote.local():\\n         missing = (set(pushop.repo.requirements)\\n                    - pushop.remote.local().supported)\\n         if missing:\\n             msg = _(\\\"required features are not\\\"\\n                     \\\" supported in the destination:\\\"\\n                     \\\" %s\\\") % (', '.join(sorted(missing)))\\n             raise error.Abort(msg)\\n \\n     if not pushop.remote.canpush():\\n         raise error.Abort(_(\\\"destination does not support push\\\"))\\n \\n     if not pushop.remote.capable('unbundle'):\\n         raise error.Abort(_('cannot push: destination does not support the '\\n                             'unbundle wire protocol command'))\\n \\n     # get lock as we might write phase data\\n     wlock = lock = None\\n     try:\\n         # bundle2 push may receive a reply bundle touching bookmarks or other\\n         # things requiring the wlock. Take it now to ensure proper ordering.\\n         maypushback = pushop.ui.configbool('experimental', 'bundle2.pushback')\\n         if (not _forcebundle1(pushop)) and maypushback:\\n             wlock = pushop.repo.wlock()\\n         lock = pushop.repo.lock()\\n         pushop.trmanager = transactionmanager(pushop.repo,\\n                                               'push-response',\\n                                               pushop.remote.url())\\n     except error.LockUnavailable as err:\\n         # source repo cannot be locked.\\n         # We do not abort the push, but just disable the local phase\\n         # synchronisation.\\n         msg = 'cannot lock source repository: %s\\\\n' % err\\n         pushop.ui.debug(msg)\\n \\n     with wlock or util.nullcontextmanager(), \\\\\\n             lock or util.nullcontextmanager(), \\\\\\n             pushop.trmanager or util.nullcontextmanager():\\n         pushop.repo.checkpush(pushop)\\n         _pushdiscovery(pushop)\\n         if not _forcebundle1(pushop):\\n             _pushbundle2(pushop)\\n         _pushchangeset(pushop)\\n         _pushsyncphase(pushop)\\n         _pushobsolete(pushop)\\n         _pushbookmark(pushop)\\n \\n     if repo.ui.configbool('experimental', 'remotenames'):\\n         logexchange.pullremotenames(repo, remote)\\n \\n     return pushop\\n \\n # list of steps to perform discovery before push\\n pushdiscoveryorder = []\\n \\n # Mapping between step name and function\\n #\\n # This exists to help extensions wrap steps if necessary\\n pushdiscoverymapping = {}\\n \\n def pushdiscovery(stepname):\\n     \\\"\\\"\\\"decorator for function performing discovery before push\\n \\n     The function is added to the step -\\u003e function mapping and appended to the\\n     list of steps.  Beware that decorated function will be added in order (this\\n     may matter).\\n \\n     You can only use this decorator for a new step, if you want to wrap a step\\n     from an extension, change the pushdiscovery dictionary directly.\\\"\\\"\\\"\\n     def dec(func):\\n         assert stepname not in pushdiscoverymapping\\n         pushdiscoverymapping[stepname] = func\\n         pushdiscoveryorder.append(stepname)\\n         return func\\n     return dec\\n \\n def _pushdiscovery(pushop):\\n     \\\"\\\"\\\"Run all discovery steps\\\"\\\"\\\"\\n     for stepname in pushdiscoveryorder:\\n         step = pushdiscoverymapping[stepname]\\n         step(pushop)\\n \\n @pushdiscovery('changeset')\\n def _pushdiscoverychangeset(pushop):\\n     \\\"\\\"\\\"discover the changeset that need to be pushed\\\"\\\"\\\"\\n     fci = discovery.findcommonincoming\\n     if pushop.revs:\\n         commoninc = fci(pushop.repo, pushop.remote, force=pushop.force,\\n                         ancestorsof=pushop.revs)\\n     else:\\n         commoninc = fci(pushop.repo, pushop.remote, force=pushop.force)\\n     common, inc, remoteheads = commoninc\\n     fco = discovery.findcommonoutgoing\\n     outgoing = fco(pushop.repo, pushop.remote, onlyheads=pushop.revs,\\n                    commoninc=commoninc, force=pushop.force)\\n     pushop.outgoing = outgoing\\n     pushop.remoteheads = remoteheads\\n     pushop.incoming = inc\\n \\n @pushdiscovery('phase')\\n def _pushdiscoveryphase(pushop):\\n     \\\"\\\"\\\"discover the phase that needs to be pushed\\n \\n     (computed for both success and failure case for changesets push)\\\"\\\"\\\"\\n     outgoing = pushop.outgoing\\n     unfi = pushop.repo.unfiltered()\\n     remotephases = listkeys(pushop.remote, 'phases')\\n \\n     if (pushop.ui.configbool('ui', '_usedassubrepo')\\n         and remotephases    # server supports phases\\n         and not pushop.outgoing.missing # no changesets to be pushed\\n         and remotephases.get('publishing', False)):\\n         # When:\\n         # - this is a subrepo push\\n         # - and remote support phase\\n         # - and no changeset are to be pushed\\n         # - and remote is publishing\\n         # We may be in issue 3781 case!\\n         # We drop the possible phase synchronisation done by\\n         # courtesy to publish changesets possibly locally draft\\n         # on the remote.\\n         pushop.outdatedphases = []\\n         pushop.fallbackoutdatedphases = []\\n         return\\n \\n     pushop.remotephases = phases.remotephasessummary(pushop.repo,\\n                                                      pushop.fallbackheads,\\n                                                      remotephases)\\n     droots = pushop.remotephases.draftroots\\n \\n     extracond = ''\\n     if not pushop.remotephases.publishing:\\n         extracond = ' and public()'\\n     revset = 'heads((%%ln::%%ln) %s)' % extracond\\n     # Get the list of all revs draft on remote by public here.\\n     # XXX Beware that revset break if droots is not strictly\\n     # XXX root we may want to ensure it is but it is costly\\n     fallback = list(unfi.set(revset, droots, pushop.fallbackheads))\\n     if not outgoing.missing:\\n         future = fallback\\n     else:\\n         # adds changeset we are going to push as draft\\n         #\\n         # should not be necessary for publishing server, but because of an\\n         # issue fixed in xxxxx we have to do it anyway.\\n         fdroots = list(unfi.set('roots(%ln  + %ln::)',\\n                        outgoing.missing, droots))\\n         fdroots = [f.node() for f in fdroots]\\n         future = list(unfi.set(revset, fdroots, pushop.futureheads))\\n     pushop.outdatedphases = future\\n     pushop.fallbackoutdatedphases = fallback\\n \\n @pushdiscovery('obsmarker')\\n def _pushdiscoveryobsmarkers(pushop):\\n     if not obsolete.isenabled(pushop.repo, obsolete.exchangeopt):\\n         return\\n \\n     if not pushop.repo.obsstore:\\n         return\\n \\n     if 'obsolete' not in listkeys(pushop.remote, 'namespaces'):\\n         return\\n \\n     repo = pushop.repo\\n     # very naive computation, that can be quite expensive on big repo.\\n     # However: evolution is currently slow on them anyway.\\n     nodes = (c.node() for c in repo.set('::%ln', pushop.futureheads))\\n     pushop.outobsmarkers = pushop.repo.obsstore.relevantmarkers(nodes)\\n \\n @pushdiscovery('bookmarks')\\n def _pushdiscoverybookmarks(pushop):\\n     ui = pushop.ui\\n     repo = pushop.repo.unfiltered()\\n     remote = pushop.remote\\n     ui.debug(\\\"checking for updated bookmarks\\\\n\\\")\\n     ancestors = ()\\n     if pushop.revs:\\n         revnums = pycompat.maplist(repo.changelog.rev, pushop.revs)\\n         ancestors = repo.changelog.ancestors(revnums, inclusive=True)\\n \\n     remotebookmark = listkeys(remote, 'bookmarks')\\n \\n     explicit = set([repo._bookmarks.expandname(bookmark)\\n                     for bookmark in pushop.bookmarks])\\n \\n     remotebookmark = bookmod.unhexlifybookmarks(remotebookmark)\\n     comp = bookmod.comparebookmarks(repo, repo._bookmarks, remotebookmark)\\n \\n     def safehex(x):\\n         if x is None:\\n             return x\\n         return hex(x)\\n \\n     def hexifycompbookmarks(bookmarks):\\n         return [(b, safehex(scid), safehex(dcid))\\n                 for (b, scid, dcid) in bookmarks]\\n \\n     comp = [hexifycompbookmarks(marks) for marks in comp]\\n     return _processcompared(pushop, ancestors, explicit, remotebookmark, comp)\\n \\n def _processcompared(pushop, pushed, explicit, remotebms, comp):\\n     \\\"\\\"\\\"take decision on bookmark to pull from the remote bookmark\\n \\n     Exist to help extensions who want to alter this behavior.\\n     \\\"\\\"\\\"\\n     addsrc, adddst, advsrc, advdst, diverge, differ, invalid, same = comp\\n \\n     repo = pushop.repo\\n \\n     for b, scid, dcid in advsrc:\\n         if b in explicit:\\n             explicit.remove(b)\\n         if not pushed or repo[scid].rev() in pushed:\\n             pushop.outbookmarks.append((b, dcid, scid))\\n     # search added bookmark\\n     for b, scid, dcid in addsrc:\\n         if b in explicit:\\n             explicit.remove(b)\\n             pushop.outbookmarks.append((b, '', scid))\\n     # search for overwritten bookmark\\n     for b, scid, dcid in list(advdst) + list(diverge) + list(differ):\\n         if b in explicit:\\n             explicit.remove(b)\\n             pushop.outbookmarks.append((b, dcid, scid))\\n     # search for bookmark to delete\\n     for b, scid, dcid in adddst:\\n         if b in explicit:\\n             explicit.remove(b)\\n             # treat as \\\"deleted locally\\\"\\n             pushop.outbookmarks.append((b, dcid, ''))\\n     # identical bookmarks shouldn't get reported\\n     for b, scid, dcid in same:\\n         if b in explicit:\\n             explicit.remove(b)\\n \\n     if explicit:\\n         explicit = sorted(explicit)\\n         # we should probably list all of them\\n         pushop.ui.warn(_('bookmark %s does not exist on the local '\\n                          'or remote repository!\\\\n') % explicit[0])\\n         pushop.bkresult = 2\\n \\n     pushop.outbookmarks.sort()\\n \\n def _pushcheckoutgoing(pushop):\\n     outgoing = pushop.outgoing\\n     unfi = pushop.repo.unfiltered()\\n     if not outgoing.missing:\\n         # nothing to push\\n         scmutil.nochangesfound(unfi.ui, unfi, outgoing.excluded)\\n         return False\\n     # something to push\\n     if not pushop.force:\\n         # if repo.obsstore == False --\\u003e no obsolete\\n         # then, save the iteration\\n         if unfi.obsstore:\\n             # this message are here for 80 char limit reason\\n             mso = _(\\\"push includes obsolete changeset: %s!\\\")\\n             mspd = _(\\\"push includes phase-divergent changeset: %s!\\\")\\n             mscd = _(\\\"push includes content-divergent changeset: %s!\\\")\\n             mst = {\\\"orphan\\\": _(\\\"push includes orphan changeset: %s!\\\"),\\n                    \\\"phase-divergent\\\": mspd,\\n                    \\\"content-divergent\\\": mscd}\\n             # If we are to push if there is at least one\\n             # obsolete or unstable changeset in missing, at\\n             # least one of the missinghead will be obsolete or\\n             # unstable. So checking heads only is ok\\n             for node in outgoing.missingheads:\\n                 ctx = unfi[node]\\n                 if ctx.obsolete():\\n                     raise error.Abort(mso % ctx)\\n                 elif ctx.isunstable():\\n                     # TODO print more than one instability in the abort\\n                     # message\\n                     raise error.Abort(mst[ctx.instabilities()[0]] % ctx)\\n \\n         discovery.checkheads(pushop)\\n     return True\\n \\n # List of names of steps to perform for an outgoing bundle2, order matters.\\n b2partsgenorder = []\\n \\n # Mapping between step name and function\\n #\\n # This exists to help extensions wrap steps if necessary\\n b2partsgenmapping = {}\\n \\n def b2partsgenerator(stepname, idx=None):\\n     \\\"\\\"\\\"decorator for function generating bundle2 part\\n \\n     The function is added to the step -\\u003e function mapping and appended to the\\n     list of steps.  Beware that decorated functions will be added in order\\n     (this may matter).\\n \\n     You can only use this decorator for new steps, if you want to wrap a step\\n     from an extension, attack the b2partsgenmapping dictionary directly.\\\"\\\"\\\"\\n     def dec(func):\\n         assert stepname not in b2partsgenmapping\\n         b2partsgenmapping[stepname] = func\\n         if idx is None:\\n             b2partsgenorder.append(stepname)\\n         else:\\n             b2partsgenorder.insert(idx, stepname)\\n         return func\\n     return dec\\n \\n def _pushb2ctxcheckheads(pushop, bundler):\\n     \\\"\\\"\\\"Generate race condition checking parts\\n \\n     Exists as an independent function to aid extensions\\n     \\\"\\\"\\\"\\n     # * 'force' do not check for push race,\\n     # * if we don't push anything, there are nothing to check.\\n     if not pushop.force and pushop.outgoing.missingheads:\\n         allowunrelated = 'related' in bundler.capabilities.get('checkheads', ())\\n         emptyremote = pushop.pushbranchmap is None\\n         if not allowunrelated or emptyremote:\\n             bundler.newpart('check:heads', data=iter(pushop.remoteheads))\\n         else:\\n             affected = set()\\n             for branch, heads in pushop.pushbranchmap.iteritems():\\n                 remoteheads, newheads, unsyncedheads, discardedheads = heads\\n                 if remoteheads is not None:\\n                     remote = set(remoteheads)\\n                     affected |= set(discardedheads) & remote\\n                     affected |= remote - set(newheads)\\n             if affected:\\n                 data = iter(sorted(affected))\\n                 bundler.newpart('check:updated-heads', data=data)\\n \\n def _pushing(pushop):\\n     \\\"\\\"\\\"return True if we are pushing anything\\\"\\\"\\\"\\n     return bool(pushop.outgoing.missing\\n                 or pushop.outdatedphases\\n                 or pushop.outobsmarkers\\n                 or pushop.outbookmarks)\\n \\n @b2partsgenerator('check-bookmarks')\\n def _pushb2checkbookmarks(pushop, bundler):\\n     \\\"\\\"\\\"insert bookmark move checking\\\"\\\"\\\"\\n     if not _pushing(pushop) or pushop.force:\\n         return\\n     b2caps = bundle2.bundle2caps(pushop.remote)\\n     hasbookmarkcheck = 'bookmarks' in b2caps\\n     if not (pushop.outbookmarks and hasbookmarkcheck):\\n         return\\n     data = []\\n     for book, old, new in pushop.outbookmarks:\\n         old = bin(old)\\n         data.append((book, old))\\n     checkdata = bookmod.binaryencode(data)\\n     bundler.newpart('check:bookmarks', data=checkdata)\\n \\n @b2partsgenerator('check-phases')\\n def _pushb2checkphases(pushop, bundler):\\n     \\\"\\\"\\\"insert phase move checking\\\"\\\"\\\"\\n     if not _pushing(pushop) or pushop.force:\\n         return\\n     b2caps = bundle2.bundle2caps(pushop.remote)\\n     hasphaseheads = 'heads' in b2caps.get('phases', ())\\n     if pushop.remotephases is not None and hasphaseheads:\\n         # check that the remote phase has not changed\\n         checks = [[] for p in phases.allphases]\\n         checks[phases.public].extend(pushop.remotephases.publicheads)\\n         checks[phases.draft].extend(pushop.remotephases.draftroots)\\n         if any(checks):\\n             for nodes in checks:\\n                 nodes.sort()\\n             checkdata = phases.binaryencode(checks)\\n             bundler.newpart('check:phases', data=checkdata)\\n \\n @b2partsgenerator('changeset')\\n def _pushb2ctx(pushop, bundler):\\n     \\\"\\\"\\\"handle changegroup push through bundle2\\n \\n     addchangegroup result is stored in the ``pushop.cgresult`` attribute.\\n     \\\"\\\"\\\"\\n     if 'changesets' in pushop.stepsdone:\\n         return\\n     pushop.stepsdone.add('changesets')\\n     # Send known heads to the server for race detection.\\n     if not _pushcheckoutgoing(pushop):\\n         return\\n     pushop.repo.prepushoutgoinghooks(pushop)\\n \\n     _pushb2ctxcheckheads(pushop, bundler)\\n \\n     b2caps = bundle2.bundle2caps(pushop.remote)\\n     version = '01'\\n     cgversions = b2caps.get('changegroup')\\n     if cgversions:  # 3.1 and 3.2 ship with an empty value\\n         cgversions = [v for v in cgversions\\n                       if v in changegroup.supportedoutgoingversions(\\n                           pushop.repo)]\\n         if not cgversions:\\n             raise ValueError(_('no common changegroup version'))\\n         version = max(cgversions)\\n     cgstream = changegroup.makestream(pushop.repo, pushop.outgoing, version,\\n                                       'push')\\n     cgpart = bundler.newpart('changegroup', data=cgstream)\\n     if cgversions:\\n         cgpart.addparam('version', version)\\n     if 'treemanifest' in pushop.repo.requirements:\\n         cgpart.addparam('treemanifest', '1')\\n     def handlereply(op):\\n         \\\"\\\"\\\"extract addchangegroup returns from server reply\\\"\\\"\\\"\\n         cgreplies = op.records.getreplies(cgpart.id)\\n         assert len(cgreplies['changegroup']) == 1\\n         pushop.cgresult = cgreplies['changegroup'][0]['return']\\n     return handlereply\\n \\n @b2partsgenerator('phase')\\n def _pushb2phases(pushop, bundler):\\n     \\\"\\\"\\\"handle phase push through bundle2\\\"\\\"\\\"\\n     if 'phases' in pushop.stepsdone:\\n         return\\n     b2caps = bundle2.bundle2caps(pushop.remote)\\n     ui = pushop.repo.ui\\n \\n     legacyphase = 'phases' in ui.configlist('devel', 'legacy.exchange')\\n     haspushkey = 'pushkey' in b2caps\\n     hasphaseheads = 'heads' in b2caps.get('phases', ())\\n \\n     if hasphaseheads and not legacyphase:\\n         return _pushb2phaseheads(pushop, bundler)\\n     elif haspushkey:\\n         return _pushb2phasespushkey(pushop, bundler)\\n \\n def _pushb2phaseheads(pushop, bundler):\\n     \\\"\\\"\\\"push phase information through a bundle2 - binary part\\\"\\\"\\\"\\n     pushop.stepsdone.add('phases')\\n     if pushop.outdatedphases:\\n         updates = [[] for p in phases.allphases]\\n         updates[0].extend(h.node() for h in pushop.outdatedphases)\\n         phasedata = phases.binaryencode(updates)\\n         bundler.newpart('phase-heads', data=phasedata)\\n \\n def _pushb2phasespushkey(pushop, bundler):\\n     \\\"\\\"\\\"push phase information through a bundle2 - pushkey part\\\"\\\"\\\"\\n     pushop.stepsdone.add('phases')\\n     part2node = []\\n \\n     def handlefailure(pushop, exc):\\n         targetid = int(exc.partid)\\n         for partid, node in part2node:\\n             if partid == targetid:\\n                 raise error.Abort(_('updating %s to public failed') % node)\\n \\n     enc = pushkey.encode\\n     for newremotehead in pushop.outdatedphases:\\n         part = bundler.newpart('pushkey')\\n         part.addparam('namespace', enc('phases'))\\n         part.addparam('key', enc(newremotehead.hex()))\\n         part.addparam('old', enc('%d' % phases.draft))\\n         part.addparam('new', enc('%d' % phases.public))\\n         part2node.append((part.id, newremotehead))\\n         pushop.pkfailcb[part.id] = handlefailure\\n \\n     def handlereply(op):\\n         for partid, node in part2node:\\n             partrep = op.records.getreplies(partid)\\n             results = partrep['pushkey']\\n             assert len(results) \\u003c= 1\\n             msg = None\\n             if not results:\\n                 msg = _('server ignored update of %s to public!\\\\n') % node\\n             elif not int(results[0]['return']):\\n                 msg = _('updating %s to public failed!\\\\n') % node\\n             if msg is not None:\\n                 pushop.ui.warn(msg)\\n     return handlereply\\n \\n @b2partsgenerator('obsmarkers')\\n def _pushb2obsmarkers(pushop, bundler):\\n     if 'obsmarkers' in pushop.stepsdone:\\n         return\\n     remoteversions = bundle2.obsmarkersversion(bundler.capabilities)\\n     if obsolete.commonversion(remoteversions) is None:\\n         return\\n     pushop.stepsdone.add('obsmarkers')\\n     if pushop.outobsmarkers:\\n         markers = sorted(pushop.outobsmarkers)\\n         bundle2.buildobsmarkerspart(bundler, markers)\\n \\n @b2partsgenerator('bookmarks')\\n def _pushb2bookmarks(pushop, bundler):\\n     \\\"\\\"\\\"handle bookmark push through bundle2\\\"\\\"\\\"\\n     if 'bookmarks' in pushop.stepsdone:\\n         return\\n     b2caps = bundle2.bundle2caps(pushop.remote)\\n \\n     legacy = pushop.repo.ui.configlist('devel', 'legacy.exchange')\\n     legacybooks = 'bookmarks' in legacy\\n \\n     if not legacybooks and 'bookmarks' in b2caps:\\n         return _pushb2bookmarkspart(pushop, bundler)\\n     elif 'pushkey' in b2caps:\\n         return _pushb2bookmarkspushkey(pushop, bundler)\\n \\n def _bmaction(old, new):\\n     \\\"\\\"\\\"small utility for bookmark pushing\\\"\\\"\\\"\\n     if not old:\\n         return 'export'\\n     elif not new:\\n         return 'delete'\\n     return 'update'\\n \\n def _pushb2bookmarkspart(pushop, bundler):\\n     pushop.stepsdone.add('bookmarks')\\n     if not pushop.outbookmarks:\\n         return\\n \\n     allactions = []\\n     data = []\\n     for book, old, new in pushop.outbookmarks:\\n         new = bin(new)\\n         data.append((book, new))\\n         allactions.append((book, _bmaction(old, new)))\\n     checkdata = bookmod.binaryencode(data)\\n     bundler.newpart('bookmarks', data=checkdata)\\n \\n     def handlereply(op):\\n         ui = pushop.ui\\n         # if success\\n         for book, action in allactions:\\n             ui.status(bookmsgmap[action][0] % book)\\n \\n     return handlereply\\n \\n def _pushb2bookmarkspushkey(pushop, bundler):\\n     pushop.stepsdone.add('bookmarks')\\n     part2book = []\\n     enc = pushkey.encode\\n \\n     def handlefailure(pushop, exc):\\n         targetid = int(exc.partid)\\n         for partid, book, action in part2book:\\n             if partid == targetid:\\n                 raise error.Abort(bookmsgmap[action][1].rstrip() % book)\\n         # we should not be called for part we did not generated\\n         assert False\\n \\n     for book, old, new in pushop.outbookmarks:\\n         part = bundler.newpart('pushkey')\\n         part.addparam('namespace', enc('bookmarks'))\\n         part.addparam('key', enc(book))\\n         part.addparam('old', enc(old))\\n         part.addparam('new', enc(new))\\n         action = 'update'\\n         if not old:\\n             action = 'export'\\n         elif not new:\\n             action = 'delete'\\n         part2book.append((part.id, book, action))\\n         pushop.pkfailcb[part.id] = handlefailure\\n \\n     def handlereply(op):\\n         ui = pushop.ui\\n         for partid, book, action in part2book:\\n             partrep = op.records.getreplies(partid)\\n             results = partrep['pushkey']\\n             assert len(results) \\u003c= 1\\n             if not results:\\n                 pushop.ui.warn(_('server ignored bookmark %s update\\\\n') % book)\\n             else:\\n                 ret = int(results[0]['return'])\\n                 if ret:\\n                     ui.status(bookmsgmap[action][0] % book)\\n                 else:\\n                     ui.warn(bookmsgmap[action][1] % book)\\n                     if pushop.bkresult is not None:\\n                         pushop.bkresult = 1\\n     return handlereply\\n \\n @b2partsgenerator('pushvars', idx=0)\\n def _getbundlesendvars(pushop, bundler):\\n     '''send shellvars via bundle2'''\\n     pushvars = pushop.pushvars\\n     if pushvars:\\n         shellvars = {}\\n         for raw in pushvars:\\n             if '=' not in raw:\\n                 msg = (\\\"unable to parse variable '%s', should follow \\\"\\n                         \\\"'KEY=VALUE' or 'KEY=' format\\\")\\n                 raise error.Abort(msg % raw)\\n             k, v = raw.split('=', 1)\\n             shellvars[k] = v\\n \\n         part = bundler.newpart('pushvars')\\n \\n         for key, value in shellvars.iteritems():\\n             part.addparam(key, value, mandatory=False)\\n \\n def _pushbundle2(pushop):\\n     \\\"\\\"\\\"push data to the remote using bundle2\\n \\n     The only currently supported type of data is changegroup but this will\\n     evolve in the future.\\\"\\\"\\\"\\n     bundler = bundle2.bundle20(pushop.ui, bundle2.bundle2caps(pushop.remote))\\n     pushback = (pushop.trmanager\\n                 and pushop.ui.configbool('experimental', 'bundle2.pushback'))\\n \\n     # create reply capability\\n     capsblob = bundle2.encodecaps(bundle2.getrepocaps(pushop.repo,\\n                                                       allowpushback=pushback,\\n                                                       role='client'))\\n     bundler.newpart('replycaps', data=capsblob)\\n     replyhandlers = []\\n     for partgenname in b2partsgenorder:\\n         partgen = b2partsgenmapping[partgenname]\\n         ret = partgen(pushop, bundler)\\n         if callable(ret):\\n             replyhandlers.append(ret)\\n     # do not push if nothing to push\\n     if bundler.nbparts \\u003c= 1:\\n         return\\n     stream = util.chunkbuffer(bundler.getchunks())\\n     try:\\n         try:\\n             with pushop.remote.commandexecutor() as e:\\n                 reply = e.callcommand('unbundle', {\\n                     'bundle': stream,\\n                     'heads': ['force'],\\n                     'url': pushop.remote.url(),\\n                 }).result()\\n         except error.BundleValueError as exc:\\n             raise error.Abort(_('missing support for %s') % exc)\\n         try:\\n             trgetter = None\\n             if pushback:\\n                 trgetter = pushop.trmanager.transaction\\n             op = bundle2.processbundle(pushop.repo, reply, trgetter)\\n         except error.BundleValueError as exc:\\n             raise error.Abort(_('missing support for %s') % exc)\\n         except bundle2.AbortFromPart as exc:\\n             pushop.ui.status(_('remote: %s\\\\n') % exc)\\n             if exc.hint is not None:\\n                 pushop.ui.status(_('remote: %s\\\\n') % ('(%s)' % exc.hint))\\n             raise error.Abort(_('push failed on remote'))\\n     except error.PushkeyFailed as exc:\\n         partid = int(exc.partid)\\n         if partid not in pushop.pkfailcb:\\n             raise\\n         pushop.pkfailcb[partid](pushop, exc)\\n     for rephand in replyhandlers:\\n         rephand(op)\\n \\n def _pushchangeset(pushop):\\n     \\\"\\\"\\\"Make the actual push of changeset bundle to remote repo\\\"\\\"\\\"\\n     if 'changesets' in pushop.stepsdone:\\n         return\\n     pushop.stepsdone.add('changesets')\\n     if not _pushcheckoutgoing(pushop):\\n         return\\n \\n     # Should have verified this in push().\\n     assert pushop.remote.capable('unbundle')\\n \\n     pushop.repo.prepushoutgoinghooks(pushop)\\n     outgoing = pushop.outgoing\\n     # TODO: get bundlecaps from remote\\n     bundlecaps = None\\n     # create a changegroup from local\\n     if pushop.revs is None and not (outgoing.excluded\\n                             or pushop.repo.changelog.filteredrevs):\\n         # push everything,\\n         # use the fast path, no race possible on push\\n         cg = changegroup.makechangegroup(pushop.repo, outgoing, '01', 'push',\\n                 fastpath=True, bundlecaps=bundlecaps)\\n     else:\\n         cg = changegroup.makechangegroup(pushop.repo, outgoing, '01',\\n                                         'push', bundlecaps=bundlecaps)\\n \\n     # apply changegroup to remote\\n     # local repo finds heads on server, finds out what\\n     # revs it must push. once revs transferred, if server\\n     # finds it has different heads (someone else won\\n     # commit\\/push race), server aborts.\\n     if pushop.force:\\n         remoteheads = ['force']\\n     else:\\n         remoteheads = pushop.remoteheads\\n     # ssh: return remote's addchangegroup()\\n     # http: return remote's addchangegroup() or 0 for error\\n     pushop.cgresult = pushop.remote.unbundle(cg, remoteheads,\\n                                         pushop.repo.url())\\n \\n def _pushsyncphase(pushop):\\n     \\\"\\\"\\\"synchronise phase information locally and remotely\\\"\\\"\\\"\\n     cheads = pushop.commonheads\\n     # even when we don't push, exchanging phase data is useful\\n     remotephases = listkeys(pushop.remote, 'phases')\\n     if (pushop.ui.configbool('ui', '_usedassubrepo')\\n         and remotephases    # server supports phases\\n         and pushop.cgresult is None # nothing was pushed\\n         and remotephases.get('publishing', False)):\\n         # When:\\n         # - this is a subrepo push\\n         # - and remote support phase\\n         # - and no changeset was pushed\\n         # - and remote is publishing\\n         # We may be in issue 3871 case!\\n         # We drop the possible phase synchronisation done by\\n         # courtesy to publish changesets possibly locally draft\\n         # on the remote.\\n         remotephases = {'publishing': 'True'}\\n     if not remotephases: # old server or public only reply from non-publishing\\n         _localphasemove(pushop, cheads)\\n         # don't push any phase data as there is nothing to push\\n     else:\\n         ana = phases.analyzeremotephases(pushop.repo, cheads,\\n                                          remotephases)\\n         pheads, droots = ana\\n         ### Apply remote phase on local\\n         if remotephases.get('publishing', False):\\n             _localphasemove(pushop, cheads)\\n         else: # publish = False\\n             _localphasemove(pushop, pheads)\\n             _localphasemove(pushop, cheads, phases.draft)\\n         ### Apply local phase on remote\\n \\n         if pushop.cgresult:\\n             if 'phases' in pushop.stepsdone:\\n                 # phases already pushed though bundle2\\n                 return\\n             outdated = pushop.outdatedphases\\n         else:\\n             outdated = pushop.fallbackoutdatedphases\\n \\n         pushop.stepsdone.add('phases')\\n \\n         # filter heads already turned public by the push\\n         outdated = [c for c in outdated if c.node() not in pheads]\\n         # fallback to independent pushkey command\\n         for newremotehead in outdated:\\n             with pushop.remote.commandexecutor() as e:\\n                 r = e.callcommand('pushkey', {\\n                     'namespace': 'phases',\\n                     'key': newremotehead.hex(),\\n                     'old': '%d' % phases.draft,\\n                     'new': '%d' % phases.public\\n                 }).result()\\n \\n             if not r:\\n                 pushop.ui.warn(_('updating %s to public failed!\\\\n')\\n                                % newremotehead)\\n \\n def _localphasemove(pushop, nodes, phase=phases.public):\\n     \\\"\\\"\\\"move \\u003cnodes\\u003e to \\u003cphase\\u003e in the local source repo\\\"\\\"\\\"\\n     if pushop.trmanager:\\n         phases.advanceboundary(pushop.repo,\\n                                pushop.trmanager.transaction(),\\n                                phase,\\n                                nodes)\\n     else:\\n         # repo is not locked, do not change any phases!\\n         # Informs the user that phases should have been moved when\\n         # applicable.\\n         actualmoves = [n for n in nodes if phase \\u003c pushop.repo[n].phase()]\\n         phasestr = phases.phasenames[phase]\\n         if actualmoves:\\n             pushop.ui.status(_('cannot lock source repo, skipping '\\n                                'local %s phase update\\\\n') % phasestr)\\n \\n def _pushobsolete(pushop):\\n     \\\"\\\"\\\"utility function to push obsolete markers to a remote\\\"\\\"\\\"\\n     if 'obsmarkers' in pushop.stepsdone:\\n         return\\n     repo = pushop.repo\\n     remote = pushop.remote\\n     pushop.stepsdone.add('obsmarkers')\\n     if pushop.outobsmarkers:\\n         pushop.ui.debug('try to push obsolete markers to remote\\\\n')\\n         rslts = []\\n         remotedata = obsolete._pushkeyescape(sorted(pushop.outobsmarkers))\\n         for key in sorted(remotedata, reverse=True):\\n             # reverse sort to ensure we end with dump0\\n             data = remotedata[key]\\n             rslts.append(remote.pushkey('obsolete', key, '', data))\\n         if [r for r in rslts if not r]:\\n             msg = _('failed to push some obsolete markers!\\\\n')\\n             repo.ui.warn(msg)\\n \\n def _pushbookmark(pushop):\\n     \\\"\\\"\\\"Update bookmark position on remote\\\"\\\"\\\"\\n     if pushop.cgresult == 0 or 'bookmarks' in pushop.stepsdone:\\n         return\\n     pushop.stepsdone.add('bookmarks')\\n     ui = pushop.ui\\n     remote = pushop.remote\\n \\n     for b, old, new in pushop.outbookmarks:\\n         action = 'update'\\n         if not old:\\n             action = 'export'\\n         elif not new:\\n             action = 'delete'\\n \\n         with remote.commandexecutor() as e:\\n             r = e.callcommand('pushkey', {\\n                 'namespace': 'bookmarks',\\n                 'key': b,\\n                 'old': old,\\n                 'new': new,\\n             }).result()\\n \\n         if r:\\n             ui.status(bookmsgmap[action][0] % b)\\n         else:\\n             ui.warn(bookmsgmap[action][1] % b)\\n             # discovery can have set the value form invalid entry\\n             if pushop.bkresult is not None:\\n                 pushop.bkresult = 1\\n \\n class pulloperation(object):\\n     \\\"\\\"\\\"A object that represent a single pull operation\\n \\n     It purpose is to carry pull related state and very common operation.\\n \\n     A new should be created at the beginning of each pull and discarded\\n     afterward.\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, repo, remote, heads=None, force=False, bookmarks=(),\\n                  remotebookmarks=None, streamclonerequested=None,\\n                  includepats=None, excludepats=None):\\n         # repo we pull into\\n         self.repo = repo\\n         # repo we pull from\\n         self.remote = remote\\n         # revision we try to pull (None is \\\"all\\\")\\n         self.heads = heads\\n         # bookmark pulled explicitly\\n         self.explicitbookmarks = [repo._bookmarks.expandname(bookmark)\\n                                   for bookmark in bookmarks]\\n         # do we force pull?\\n         self.force = force\\n         # whether a streaming clone was requested\\n         self.streamclonerequested = streamclonerequested\\n         # transaction manager\\n         self.trmanager = None\\n         # set of common changeset between local and remote before pull\\n         self.common = None\\n         # set of pulled head\\n         self.rheads = None\\n         # list of missing changeset to fetch remotely\\n         self.fetch = None\\n         # remote bookmarks data\\n         self.remotebookmarks = remotebookmarks\\n         # result of changegroup pulling (used as return code by pull)\\n         self.cgresult = None\\n         # list of step already done\\n         self.stepsdone = set()\\n         # Whether we attempted a clone from pre-generated bundles.\\n         self.clonebundleattempted = False\\n         # Set of file patterns to include.\\n         self.includepats = includepats\\n         # Set of file patterns to exclude.\\n         self.excludepats = excludepats\\n \\n     @util.propertycache\\n     def pulledsubset(self):\\n         \\\"\\\"\\\"heads of the set of changeset target by the pull\\\"\\\"\\\"\\n         # compute target subset\\n         if self.heads is None:\\n             # We pulled every thing possible\\n             # sync on everything common\\n             c = set(self.common)\\n             ret = list(self.common)\\n             for n in self.rheads:\\n                 if n not in c:\\n                     ret.append(n)\\n             return ret\\n         else:\\n             # We pulled a specific subset\\n             # sync on this subset\\n             return self.heads\\n \\n     @util.propertycache\\n     def canusebundle2(self):\\n         return not _forcebundle1(self)\\n \\n     @util.propertycache\\n     def remotebundle2caps(self):\\n         return bundle2.bundle2caps(self.remote)\\n \\n     def gettransaction(self):\\n         # deprecated; talk to trmanager directly\\n         return self.trmanager.transaction()\\n \\n class transactionmanager(util.transactional):\\n     \\\"\\\"\\\"An object to manage the life cycle of a transaction\\n \\n     It creates the transaction on demand and calls the appropriate hooks when\\n     closing the transaction.\\\"\\\"\\\"\\n     def __init__(self, repo, source, url):\\n         self.repo = repo\\n         self.source = source\\n         self.url = url\\n         self._tr = None\\n \\n     def transaction(self):\\n         \\\"\\\"\\\"Return an open transaction object, constructing if necessary\\\"\\\"\\\"\\n         if not self._tr:\\n             trname = '%s\\\\n%s' % (self.source, util.hidepassword(self.url))\\n             self._tr = self.repo.transaction(trname)\\n             self._tr.hookargs['source'] = self.source\\n             self._tr.hookargs['url'] = self.url\\n         return self._tr\\n \\n     def close(self):\\n         \\\"\\\"\\\"close transaction if created\\\"\\\"\\\"\\n         if self._tr is not None:\\n             self._tr.close()\\n \\n     def release(self):\\n         \\\"\\\"\\\"release transaction if created\\\"\\\"\\\"\\n         if self._tr is not None:\\n             self._tr.release()\\n \\n def listkeys(remote, namespace):\\n     with remote.commandexecutor() as e:\\n         return e.callcommand('listkeys', {'namespace': namespace}).result()\\n \\n def _fullpullbundle2(repo, pullop):\\n     # The server may send a partial reply, i.e. when inlining\\n     # pre-computed bundles. In that case, update the common\\n     # set based on the results and pull another bundle.\\n     #\\n     # There are two indicators that the process is finished:\\n     # - no changeset has been added, or\\n     # - all remote heads are known locally.\\n     # The head check must use the unfiltered view as obsoletion\\n     # markers can hide heads.\\n     unfi = repo.unfiltered()\\n     unficl = unfi.changelog\\n     def headsofdiff(h1, h2):\\n         \\\"\\\"\\\"Returns heads(h1 % h2)\\\"\\\"\\\"\\n         res = unfi.set('heads(%ln %% %ln)', h1, h2)\\n         return set(ctx.node() for ctx in res)\\n     def headsofunion(h1, h2):\\n         \\\"\\\"\\\"Returns heads((h1 + h2) - null)\\\"\\\"\\\"\\n         res = unfi.set('heads((%ln + %ln - null))', h1, h2)\\n         return set(ctx.node() for ctx in res)\\n     while True:\\n         old_heads = unficl.heads()\\n         clstart = len(unficl)\\n         _pullbundle2(pullop)\\n         if repository.NARROW_REQUIREMENT in repo.requirements:\\n             # XXX narrow clones filter the heads on the server side during\\n             # XXX getbundle and result in partial replies as well.\\n             # XXX Disable pull bundles in this case as band aid to avoid\\n             # XXX extra round trips.\\n             break\\n         if clstart == len(unficl):\\n             break\\n         if all(unficl.hasnode(n) for n in pullop.rheads):\\n             break\\n         new_heads = headsofdiff(unficl.heads(), old_heads)\\n         pullop.common = headsofunion(new_heads, pullop.common)\\n         pullop.rheads = set(pullop.rheads) - pullop.common\\n \\n def pull(repo, remote, heads=None, force=False, bookmarks=(), opargs=None,\\n          streamclonerequested=None, includepats=None, excludepats=None):\\n     \\\"\\\"\\\"Fetch repository data from a remote.\\n \\n     This is the main function used to retrieve data from a remote repository.\\n \\n     ``repo`` is the local repository to clone into.\\n     ``remote`` is a peer instance.\\n     ``heads`` is an iterable of revisions we want to pull. ``None`` (the\\n     default) means to pull everything from the remote.\\n     ``bookmarks`` is an iterable of bookmarks requesting to be pulled. By\\n     default, all remote bookmarks are pulled.\\n     ``opargs`` are additional keyword arguments to pass to ``pulloperation``\\n     initialization.\\n     ``streamclonerequested`` is a boolean indicating whether a \\\"streaming\\n     clone\\\" is requested. A \\\"streaming clone\\\" is essentially a raw file copy\\n     of revlogs from the server. This only works when the local repository is\\n     empty. The default value of ``None`` means to respect the server\\n     configuration for preferring stream clones.\\n     ``includepats`` and ``excludepats`` define explicit file patterns to\\n     include and exclude in storage, respectively. If not defined, narrow\\n     patterns from the repo instance are used, if available.\\n \\n     Returns the ``pulloperation`` created for this pull.\\n     \\\"\\\"\\\"\\n     if opargs is None:\\n         opargs = {}\\n \\n     # We allow the narrow patterns to be passed in explicitly to provide more\\n     # flexibility for API consumers.\\n     if includepats or excludepats:\\n         includepats = includepats or set()\\n         excludepats = excludepats or set()\\n     else:\\n         includepats, excludepats = repo.narrowpats\\n \\n     narrowspec.validatepatterns(includepats)\\n     narrowspec.validatepatterns(excludepats)\\n \\n     pullop = pulloperation(repo, remote, heads, force, bookmarks=bookmarks,\\n                            streamclonerequested=streamclonerequested,\\n                            includepats=includepats, excludepats=excludepats,\\n                            **pycompat.strkwargs(opargs))\\n \\n     peerlocal = pullop.remote.local()\\n     if peerlocal:\\n         missing = set(peerlocal.requirements) - pullop.repo.supported\\n         if missing:\\n             msg = _(\\\"required features are not\\\"\\n                     \\\" supported in the destination:\\\"\\n                     \\\" %s\\\") % (', '.join(sorted(missing)))\\n             raise error.Abort(msg)\\n \\n     pullop.trmanager = transactionmanager(repo, 'pull', remote.url())\\n     with repo.wlock(), repo.lock(), pullop.trmanager:\\n-        # This should ideally be in _pullbundle2(). However, it needs to run\\n-        # before discovery to avoid extra work.\\n-        _maybeapplyclonebundle(pullop)\\n-        streamclone.maybeperformlegacystreamclone(pullop)\\n-        _pulldiscovery(pullop)\\n-        if pullop.canusebundle2:\\n-            _fullpullbundle2(repo, pullop)\\n-        _pullchangeset(pullop)\\n-        _pullphase(pullop)\\n-        _pullbookmarks(pullop)\\n-        _pullobsolete(pullop)\\n+        # Use the modern wire protocol, if available.\\n+        if remote.capable('exchangev2'):\\n+            exchangev2.pull(pullop)\\n+        else:\\n+            # This should ideally be in _pullbundle2(). However, it needs to run\\n+            # before discovery to avoid extra work.\\n+            _maybeapplyclonebundle(pullop)\\n+            streamclone.maybeperformlegacystreamclone(pullop)\\n+            _pulldiscovery(pullop)\\n+            if pullop.canusebundle2:\\n+                _fullpullbundle2(repo, pullop)\\n+            _pullchangeset(pullop)\\n+            _pullphase(pullop)\\n+            _pullbookmarks(pullop)\\n+            _pullobsolete(pullop)\\n \\n     # storing remotenames\\n     if repo.ui.configbool('experimental', 'remotenames'):\\n         logexchange.pullremotenames(repo, remote)\\n \\n     return pullop\\n \\n # list of steps to perform discovery before pull\\n pulldiscoveryorder = []\\n \\n # Mapping between step name and function\\n #\\n # This exists to help extensions wrap steps if necessary\\n pulldiscoverymapping = {}\\n \\n def pulldiscovery(stepname):\\n     \\\"\\\"\\\"decorator for function performing discovery before pull\\n \\n     The function is added to the step -\\u003e function mapping and appended to the\\n     list of steps.  Beware that decorated function will be added in order (this\\n     may matter).\\n \\n     You can only use this decorator for a new step, if you want to wrap a step\\n     from an extension, change the pulldiscovery dictionary directly.\\\"\\\"\\\"\\n     def dec(func):\\n         assert stepname not in pulldiscoverymapping\\n         pulldiscoverymapping[stepname] = func\\n         pulldiscoveryorder.append(stepname)\\n         return func\\n     return dec\\n \\n def _pulldiscovery(pullop):\\n     \\\"\\\"\\\"Run all discovery steps\\\"\\\"\\\"\\n     for stepname in pulldiscoveryorder:\\n         step = pulldiscoverymapping[stepname]\\n         step(pullop)\\n \\n @pulldiscovery('b1:bookmarks')\\n def _pullbookmarkbundle1(pullop):\\n     \\\"\\\"\\\"fetch bookmark data in bundle1 case\\n \\n     If not using bundle2, we have to fetch bookmarks before changeset\\n     discovery to reduce the chance and impact of race conditions.\\\"\\\"\\\"\\n     if pullop.remotebookmarks is not None:\\n         return\\n     if pullop.canusebundle2 and 'listkeys' in pullop.remotebundle2caps:\\n         # all known bundle2 servers now support listkeys, but lets be nice with\\n         # new implementation.\\n         return\\n     books = listkeys(pullop.remote, 'bookmarks')\\n     pullop.remotebookmarks = bookmod.unhexlifybookmarks(books)\\n \\n \\n @pulldiscovery('changegroup')\\n def _pulldiscoverychangegroup(pullop):\\n     \\\"\\\"\\\"discovery phase for the pull\\n \\n     Current handle changeset discovery only, will change handle all discovery\\n     at some point.\\\"\\\"\\\"\\n     tmp = discovery.findcommonincoming(pullop.repo,\\n                                        pullop.remote,\\n                                        heads=pullop.heads,\\n                                        force=pullop.force)\\n     common, fetch, rheads = tmp\\n     nm = pullop.repo.unfiltered().changelog.nodemap\\n     if fetch and rheads:\\n         # If a remote heads is filtered locally, put in back in common.\\n         #\\n         # This is a hackish solution to catch most of \\\"common but locally\\n         # hidden situation\\\".  We do not performs discovery on unfiltered\\n         # repository because it end up doing a pathological amount of round\\n         # trip for w huge amount of changeset we do not care about.\\n         #\\n         # If a set of such \\\"common but filtered\\\" changeset exist on the server\\n         # but are not including a remote heads, we'll not be able to detect it,\\n         scommon = set(common)\\n         for n in rheads:\\n             if n in nm:\\n                 if n not in scommon:\\n                     common.append(n)\\n         if set(rheads).issubset(set(common)):\\n             fetch = []\\n     pullop.common = common\\n     pullop.fetch = fetch\\n     pullop.rheads = rheads\\n \\n def _pullbundle2(pullop):\\n     \\\"\\\"\\\"pull data using bundle2\\n \\n     For now, the only supported data are changegroup.\\\"\\\"\\\"\\n     kwargs = {'bundlecaps': caps20to10(pullop.repo, role='client')}\\n \\n     # make ui easier to access\\n     ui = pullop.repo.ui\\n \\n     # At the moment we don't do stream clones over bundle2. If that is\\n     # implemented then here's where the check for that will go.\\n     streaming = streamclone.canperformstreamclone(pullop, bundle2=True)[0]\\n \\n     # declare pull perimeters\\n     kwargs['common'] = pullop.common\\n     kwargs['heads'] = pullop.heads or pullop.rheads\\n \\n     if streaming:\\n         kwargs['cg'] = False\\n         kwargs['stream'] = True\\n         pullop.stepsdone.add('changegroup')\\n         pullop.stepsdone.add('phases')\\n \\n     else:\\n         # pulling changegroup\\n         pullop.stepsdone.add('changegroup')\\n \\n         kwargs['cg'] = pullop.fetch\\n \\n         legacyphase = 'phases' in ui.configlist('devel', 'legacy.exchange')\\n         hasbinaryphase = 'heads' in pullop.remotebundle2caps.get('phases', ())\\n         if (not legacyphase and hasbinaryphase):\\n             kwargs['phases'] = True\\n             pullop.stepsdone.add('phases')\\n \\n         if 'listkeys' in pullop.remotebundle2caps:\\n             if 'phases' not in pullop.stepsdone:\\n                 kwargs['listkeys'] = ['phases']\\n \\n     bookmarksrequested = False\\n     legacybookmark = 'bookmarks' in ui.configlist('devel', 'legacy.exchange')\\n     hasbinarybook = 'bookmarks' in pullop.remotebundle2caps\\n \\n     if pullop.remotebookmarks is not None:\\n         pullop.stepsdone.add('request-bookmarks')\\n \\n     if ('request-bookmarks' not in pullop.stepsdone\\n         and pullop.remotebookmarks is None\\n         and not legacybookmark and hasbinarybook):\\n         kwargs['bookmarks'] = True\\n         bookmarksrequested = True\\n \\n     if 'listkeys' in pullop.remotebundle2caps:\\n         if 'request-bookmarks' not in pullop.stepsdone:\\n             # make sure to always includes bookmark data when migrating\\n             # `hg incoming --bundle` to using this function.\\n             pullop.stepsdone.add('request-bookmarks')\\n             kwargs.setdefault('listkeys', []).append('bookmarks')\\n \\n     # If this is a full pull \\/ clone and the server supports the clone bundles\\n     # feature, tell the server whether we attempted a clone bundle. The\\n     # presence of this flag indicates the client supports clone bundles. This\\n     # will enable the server to treat clients that support clone bundles\\n     # differently from those that don't.\\n     if (pullop.remote.capable('clonebundles')\\n         and pullop.heads is None and list(pullop.common) == [nullid]):\\n         kwargs['cbattempted'] = pullop.clonebundleattempted\\n \\n     if streaming:\\n         pullop.repo.ui.status(_('streaming all changes\\\\n'))\\n     elif not pullop.fetch:\\n         pullop.repo.ui.status(_(\\\"no changes found\\\\n\\\"))\\n         pullop.cgresult = 0\\n     else:\\n         if pullop.heads is None and list(pullop.common) == [nullid]:\\n             pullop.repo.ui.status(_(\\\"requesting all changes\\\\n\\\"))\\n     if obsolete.isenabled(pullop.repo, obsolete.exchangeopt):\\n         remoteversions = bundle2.obsmarkersversion(pullop.remotebundle2caps)\\n         if obsolete.commonversion(remoteversions) is not None:\\n             kwargs['obsmarkers'] = True\\n             pullop.stepsdone.add('obsmarkers')\\n     _pullbundle2extraprepare(pullop, kwargs)\\n \\n     with pullop.remote.commandexecutor() as e:\\n         args = dict(kwargs)\\n         args['source'] = 'pull'\\n         bundle = e.callcommand('getbundle', args).result()\\n \\n         try:\\n             op = bundle2.bundleoperation(pullop.repo, pullop.gettransaction,\\n                                          source='pull')\\n             op.modes['bookmarks'] = 'records'\\n             bundle2.processbundle(pullop.repo, bundle, op=op)\\n         except bundle2.AbortFromPart as exc:\\n             pullop.repo.ui.status(_('remote: abort: %s\\\\n') % exc)\\n             raise error.Abort(_('pull failed on remote'), hint=exc.hint)\\n         except error.BundleValueError as exc:\\n             raise error.Abort(_('missing support for %s') % exc)\\n \\n     if pullop.fetch:\\n         pullop.cgresult = bundle2.combinechangegroupresults(op)\\n \\n     # processing phases change\\n     for namespace, value in op.records['listkeys']:\\n         if namespace == 'phases':\\n             _pullapplyphases(pullop, value)\\n \\n     # processing bookmark update\\n     if bookmarksrequested:\\n         books = {}\\n         for record in op.records['bookmarks']:\\n             books[record['bookmark']] = record[\\\"node\\\"]\\n         pullop.remotebookmarks = books\\n     else:\\n         for namespace, value in op.records['listkeys']:\\n             if namespace == 'bookmarks':\\n                 pullop.remotebookmarks = bookmod.unhexlifybookmarks(value)\\n \\n     # bookmark data were either already there or pulled in the bundle\\n     if pullop.remotebookmarks is not None:\\n         _pullbookmarks(pullop)\\n \\n def _pullbundle2extraprepare(pullop, kwargs):\\n     \\\"\\\"\\\"hook function so that extensions can extend the getbundle call\\\"\\\"\\\"\\n \\n def _pullchangeset(pullop):\\n     \\\"\\\"\\\"pull changeset from unbundle into the local repo\\\"\\\"\\\"\\n     # We delay the open of the transaction as late as possible so we\\n     # don't open transaction for nothing or you break future useful\\n     # rollback call\\n     if 'changegroup' in pullop.stepsdone:\\n         return\\n     pullop.stepsdone.add('changegroup')\\n     if not pullop.fetch:\\n         pullop.repo.ui.status(_(\\\"no changes found\\\\n\\\"))\\n         pullop.cgresult = 0\\n         return\\n     tr = pullop.gettransaction()\\n     if pullop.heads is None and list(pullop.common) == [nullid]:\\n         pullop.repo.ui.status(_(\\\"requesting all changes\\\\n\\\"))\\n     elif pullop.heads is None and pullop.remote.capable('changegroupsubset'):\\n         # issue1320, avoid a race if remote changed after discovery\\n         pullop.heads = pullop.rheads\\n \\n     if pullop.remote.capable('getbundle'):\\n         # TODO: get bundlecaps from remote\\n         cg = pullop.remote.getbundle('pull', common=pullop.common,\\n                                      heads=pullop.heads or pullop.rheads)\\n     elif pullop.heads is None:\\n         with pullop.remote.commandexecutor() as e:\\n             cg = e.callcommand('changegroup', {\\n                 'nodes': pullop.fetch,\\n                 'source': 'pull',\\n             }).result()\\n \\n     elif not pullop.remote.capable('changegroupsubset'):\\n         raise error.Abort(_(\\\"partial pull cannot be done because \\\"\\n                            \\\"other repository doesn't support \\\"\\n                            \\\"changegroupsubset.\\\"))\\n     else:\\n         with pullop.remote.commandexecutor() as e:\\n             cg = e.callcommand('changegroupsubset', {\\n                 'bases': pullop.fetch,\\n                 'heads': pullop.heads,\\n                 'source': 'pull',\\n             }).result()\\n \\n     bundleop = bundle2.applybundle(pullop.repo, cg, tr, 'pull',\\n                                    pullop.remote.url())\\n     pullop.cgresult = bundle2.combinechangegroupresults(bundleop)\\n \\n def _pullphase(pullop):\\n     # Get remote phases data from remote\\n     if 'phases' in pullop.stepsdone:\\n         return\\n     remotephases = listkeys(pullop.remote, 'phases')\\n     _pullapplyphases(pullop, remotephases)\\n \\n def _pullapplyphases(pullop, remotephases):\\n     \\\"\\\"\\\"apply phase movement from observed remote state\\\"\\\"\\\"\\n     if 'phases' in pullop.stepsdone:\\n         return\\n     pullop.stepsdone.add('phases')\\n     publishing = bool(remotephases.get('publishing', False))\\n     if remotephases and not publishing:\\n         # remote is new and non-publishing\\n         pheads, _dr = phases.analyzeremotephases(pullop.repo,\\n                                                  pullop.pulledsubset,\\n                                                  remotephases)\\n         dheads = pullop.pulledsubset\\n     else:\\n         # Remote is old or publishing all common changesets\\n         # should be seen as public\\n         pheads = pullop.pulledsubset\\n         dheads = []\\n     unfi = pullop.repo.unfiltered()\\n     phase = unfi._phasecache.phase\\n     rev = unfi.changelog.nodemap.get\\n     public = phases.public\\n     draft = phases.draft\\n \\n     # exclude changesets already public locally and update the others\\n     pheads = [pn for pn in pheads if phase(unfi, rev(pn)) \\u003e public]\\n     if pheads:\\n         tr = pullop.gettransaction()\\n         phases.advanceboundary(pullop.repo, tr, public, pheads)\\n \\n     # exclude changesets already draft locally and update the others\\n     dheads = [pn for pn in dheads if phase(unfi, rev(pn)) \\u003e draft]\\n     if dheads:\\n         tr = pullop.gettransaction()\\n         phases.advanceboundary(pullop.repo, tr, draft, dheads)\\n \\n def _pullbookmarks(pullop):\\n     \\\"\\\"\\\"process the remote bookmark information to update the local one\\\"\\\"\\\"\\n     if 'bookmarks' in pullop.stepsdone:\\n         return\\n     pullop.stepsdone.add('bookmarks')\\n     repo = pullop.repo\\n     remotebookmarks = pullop.remotebookmarks\\n     bookmod.updatefromremote(repo.ui, repo, remotebookmarks,\\n                              pullop.remote.url(),\\n                              pullop.gettransaction,\\n                              explicit=pullop.explicitbookmarks)\\n \\n def _pullobsolete(pullop):\\n     \\\"\\\"\\\"utility function to pull obsolete markers from a remote\\n \\n     The `gettransaction` is function that return the pull transaction, creating\\n     one if necessary. We return the transaction to inform the calling code that\\n     a new transaction have been created (when applicable).\\n \\n     Exists mostly to allow overriding for experimentation purpose\\\"\\\"\\\"\\n     if 'obsmarkers' in pullop.stepsdone:\\n         return\\n     pullop.stepsdone.add('obsmarkers')\\n     tr = None\\n     if obsolete.isenabled(pullop.repo, obsolete.exchangeopt):\\n         pullop.repo.ui.debug('fetching remote obsolete markers\\\\n')\\n         remoteobs = listkeys(pullop.remote, 'obsolete')\\n         if 'dump0' in remoteobs:\\n             tr = pullop.gettransaction()\\n             markers = []\\n             for key in sorted(remoteobs, reverse=True):\\n                 if key.startswith('dump'):\\n                     data = util.b85decode(remoteobs[key])\\n                     version, newmarks = obsolete._readmarkers(data)\\n                     markers += newmarks\\n             if markers:\\n                 pullop.repo.obsstore.add(tr, markers)\\n             pullop.repo.invalidatevolatilesets()\\n     return tr\\n \\n def applynarrowacl(repo, kwargs):\\n     \\\"\\\"\\\"Apply narrow fetch access control.\\n \\n     This massages the named arguments for getbundle wire protocol commands\\n     so requested data is filtered through access control rules.\\n     \\\"\\\"\\\"\\n     ui = repo.ui\\n     # TODO this assumes existence of HTTP and is a layering violation.\\n     username = ui.shortuser(ui.environ.get('REMOTE_USER') or ui.username())\\n     user_includes = ui.configlist(\\n         _NARROWACL_SECTION, username + '.includes',\\n         ui.configlist(_NARROWACL_SECTION, 'default.includes'))\\n     user_excludes = ui.configlist(\\n         _NARROWACL_SECTION, username + '.excludes',\\n         ui.configlist(_NARROWACL_SECTION, 'default.excludes'))\\n     if not user_includes:\\n         raise error.Abort(_(\\\"{} configuration for user {} is empty\\\")\\n                           .format(_NARROWACL_SECTION, username))\\n \\n     user_includes = [\\n         'path:.' if p == '*' else 'path:' + p for p in user_includes]\\n     user_excludes = [\\n         'path:.' if p == '*' else 'path:' + p for p in user_excludes]\\n \\n     req_includes = set(kwargs.get(r'includepats', []))\\n     req_excludes = set(kwargs.get(r'excludepats', []))\\n \\n     req_includes, req_excludes, invalid_includes = narrowspec.restrictpatterns(\\n         req_includes, req_excludes, user_includes, user_excludes)\\n \\n     if invalid_includes:\\n         raise error.Abort(\\n             _(\\\"The following includes are not accessible for {}: {}\\\")\\n             .format(username, invalid_includes))\\n \\n     new_args = {}\\n     new_args.update(kwargs)\\n     new_args[r'narrow'] = True\\n     new_args[r'includepats'] = req_includes\\n     if req_excludes:\\n         new_args[r'excludepats'] = req_excludes\\n \\n     return new_args\\n \\n def _computeellipsis(repo, common, heads, known, match, depth=None):\\n     \\\"\\\"\\\"Compute the shape of a narrowed DAG.\\n \\n     Args:\\n       repo: The repository we're transferring.\\n       common: The roots of the DAG range we're transferring.\\n               May be just [nullid], which means all ancestors of heads.\\n       heads: The heads of the DAG range we're transferring.\\n       match: The narrowmatcher that allows us to identify relevant changes.\\n       depth: If not None, only consider nodes to be full nodes if they are at\\n              most depth changesets away from one of heads.\\n \\n     Returns:\\n       A tuple of (visitnodes, relevant_nodes, ellipsisroots) where:\\n \\n         visitnodes: The list of nodes (either full or ellipsis) which\\n                     need to be sent to the client.\\n         relevant_nodes: The set of changelog nodes which change a file inside\\n                  the narrowspec. The client needs these as non-ellipsis nodes.\\n         ellipsisroots: A dict of {rev: parents} that is used in\\n                        narrowchangegroup to produce ellipsis nodes with the\\n                        correct parents.\\n     \\\"\\\"\\\"\\n     cl = repo.changelog\\n     mfl = repo.manifestlog\\n \\n     clrev = cl.rev\\n \\n     commonrevs = {clrev(n) for n in common} | {nullrev}\\n     headsrevs = {clrev(n) for n in heads}\\n \\n     if depth:\\n         revdepth = {h: 0 for h in headsrevs}\\n \\n     ellipsisheads = collections.defaultdict(set)\\n     ellipsisroots = collections.defaultdict(set)\\n \\n     def addroot(head, curchange):\\n         \\\"\\\"\\\"Add a root to an ellipsis head, splitting heads with 3 roots.\\\"\\\"\\\"\\n         ellipsisroots[head].add(curchange)\\n         # Recursively split ellipsis heads with 3 roots by finding the\\n         # roots' youngest common descendant which is an elided merge commit.\\n         # That descendant takes 2 of the 3 roots as its own, and becomes a\\n         # root of the head.\\n         while len(ellipsisroots[head]) \\u003e 2:\\n             child, roots = splithead(head)\\n             splitroots(head, child, roots)\\n             head = child  # Recurse in case we just added a 3rd root\\n \\n     def splitroots(head, child, roots):\\n         ellipsisroots[head].difference_update(roots)\\n         ellipsisroots[head].add(child)\\n         ellipsisroots[child].update(roots)\\n         ellipsisroots[child].discard(child)\\n \\n     def splithead(head):\\n         r1, r2, r3 = sorted(ellipsisroots[head])\\n         for nr1, nr2 in ((r2, r3), (r1, r3), (r1, r2)):\\n             mid = repo.revs('sort(merge() & %d::%d & %d::%d, -rev)',\\n                             nr1, head, nr2, head)\\n             for j in mid:\\n                 if j == nr2:\\n                     return nr2, (nr1, nr2)\\n                 if j not in ellipsisroots or len(ellipsisroots[j]) \\u003c 2:\\n                     return j, (nr1, nr2)\\n         raise error.Abort(_('Failed to split up ellipsis node! head: %d, '\\n                             'roots: %d %d %d') % (head, r1, r2, r3))\\n \\n     missing = list(cl.findmissingrevs(common=commonrevs, heads=headsrevs))\\n     visit = reversed(missing)\\n     relevant_nodes = set()\\n     visitnodes = [cl.node(m) for m in missing]\\n     required = set(headsrevs) | known\\n     for rev in visit:\\n         clrev = cl.changelogrevision(rev)\\n         ps = [prev for prev in cl.parentrevs(rev) if prev != nullrev]\\n         if depth is not None:\\n             curdepth = revdepth[rev]\\n             for p in ps:\\n                 revdepth[p] = min(curdepth + 1, revdepth.get(p, depth + 1))\\n         needed = False\\n         shallow_enough = depth is None or revdepth[rev] \\u003c= depth\\n         if shallow_enough:\\n             curmf = mfl[clrev.manifest].read()\\n             if ps:\\n                 # We choose to not trust the changed files list in\\n                 # changesets because it's not always correct. TODO: could\\n                 # we trust it for the non-merge case?\\n                 p1mf = mfl[cl.changelogrevision(ps[0]).manifest].read()\\n                 needed = bool(curmf.diff(p1mf, match))\\n                 if not needed and len(ps) \\u003e 1:\\n                     # For merge changes, the list of changed files is not\\n                     # helpful, since we need to emit the merge if a file\\n                     # in the narrow spec has changed on either side of the\\n                     # merge. As a result, we do a manifest diff to check.\\n                     p2mf = mfl[cl.changelogrevision(ps[1]).manifest].read()\\n                     needed = bool(curmf.diff(p2mf, match))\\n             else:\\n                 # For a root node, we need to include the node if any\\n                 # files in the node match the narrowspec.\\n                 needed = any(curmf.walk(match))\\n \\n         if needed:\\n             for head in ellipsisheads[rev]:\\n                 addroot(head, rev)\\n             for p in ps:\\n                 required.add(p)\\n             relevant_nodes.add(cl.node(rev))\\n         else:\\n             if not ps:\\n                 ps = [nullrev]\\n             if rev in required:\\n                 for head in ellipsisheads[rev]:\\n                     addroot(head, rev)\\n                 for p in ps:\\n                     ellipsisheads[p].add(rev)\\n             else:\\n                 for p in ps:\\n                     ellipsisheads[p] |= ellipsisheads[rev]\\n \\n     # add common changesets as roots of their reachable ellipsis heads\\n     for c in commonrevs:\\n         for head in ellipsisheads[c]:\\n             addroot(head, c)\\n     return visitnodes, relevant_nodes, ellipsisroots\\n \\n def caps20to10(repo, role):\\n     \\\"\\\"\\\"return a set with appropriate options to use bundle20 during getbundle\\\"\\\"\\\"\\n     caps = {'HG20'}\\n     capsblob = bundle2.encodecaps(bundle2.getrepocaps(repo, role=role))\\n     caps.add('bundle2=' + urlreq.quote(capsblob))\\n     return caps\\n \\n # List of names of steps to perform for a bundle2 for getbundle, order matters.\\n getbundle2partsorder = []\\n \\n # Mapping between step name and function\\n #\\n # This exists to help extensions wrap steps if necessary\\n getbundle2partsmapping = {}\\n \\n def getbundle2partsgenerator(stepname, idx=None):\\n     \\\"\\\"\\\"decorator for function generating bundle2 part for getbundle\\n \\n     The function is added to the step -\\u003e function mapping and appended to the\\n     list of steps.  Beware that decorated functions will be added in order\\n     (this may matter).\\n \\n     You can only use this decorator for new steps, if you want to wrap a step\\n     from an extension, attack the getbundle2partsmapping dictionary directly.\\\"\\\"\\\"\\n     def dec(func):\\n         assert stepname not in getbundle2partsmapping\\n         getbundle2partsmapping[stepname] = func\\n         if idx is None:\\n             getbundle2partsorder.append(stepname)\\n         else:\\n             getbundle2partsorder.insert(idx, stepname)\\n         return func\\n     return dec\\n \\n def bundle2requested(bundlecaps):\\n     if bundlecaps is not None:\\n         return any(cap.startswith('HG2') for cap in bundlecaps)\\n     return False\\n \\n def getbundlechunks(repo, source, heads=None, common=None, bundlecaps=None,\\n                     **kwargs):\\n     \\\"\\\"\\\"Return chunks constituting a bundle's raw data.\\n \\n     Could be a bundle HG10 or a bundle HG20 depending on bundlecaps\\n     passed.\\n \\n     Returns a 2-tuple of a dict with metadata about the generated bundle\\n     and an iterator over raw chunks (of varying sizes).\\n     \\\"\\\"\\\"\\n     kwargs = pycompat.byteskwargs(kwargs)\\n     info = {}\\n     usebundle2 = bundle2requested(bundlecaps)\\n     # bundle10 case\\n     if not usebundle2:\\n         if bundlecaps and not kwargs.get('cg', True):\\n             raise ValueError(_('request for bundle10 must include changegroup'))\\n \\n         if kwargs:\\n             raise ValueError(_('unsupported getbundle arguments: %s')\\n                              % ', '.join(sorted(kwargs.keys())))\\n         outgoing = _computeoutgoing(repo, heads, common)\\n         info['bundleversion'] = 1\\n         return info, changegroup.makestream(repo, outgoing, '01', source,\\n                                             bundlecaps=bundlecaps)\\n \\n     # bundle20 case\\n     info['bundleversion'] = 2\\n     b2caps = {}\\n     for bcaps in bundlecaps:\\n         if bcaps.startswith('bundle2='):\\n             blob = urlreq.unquote(bcaps[len('bundle2='):])\\n             b2caps.update(bundle2.decodecaps(blob))\\n     bundler = bundle2.bundle20(repo.ui, b2caps)\\n \\n     kwargs['heads'] = heads\\n     kwargs['common'] = common\\n \\n     for name in getbundle2partsorder:\\n         func = getbundle2partsmapping[name]\\n         func(bundler, repo, source, bundlecaps=bundlecaps, b2caps=b2caps,\\n              **pycompat.strkwargs(kwargs))\\n \\n     info['prefercompressed'] = bundler.prefercompressed\\n \\n     return info, bundler.getchunks()\\n \\n @getbundle2partsgenerator('stream2')\\n def _getbundlestream2(bundler, repo, *args, **kwargs):\\n     return bundle2.addpartbundlestream2(bundler, repo, **kwargs)\\n \\n @getbundle2partsgenerator('changegroup')\\n def _getbundlechangegrouppart(bundler, repo, source, bundlecaps=None,\\n                               b2caps=None, heads=None, common=None, **kwargs):\\n     \\\"\\\"\\\"add a changegroup part to the requested bundle\\\"\\\"\\\"\\n     if not kwargs.get(r'cg', True):\\n         return\\n \\n     version = '01'\\n     cgversions = b2caps.get('changegroup')\\n     if cgversions:  # 3.1 and 3.2 ship with an empty value\\n         cgversions = [v for v in cgversions\\n                       if v in changegroup.supportedoutgoingversions(repo)]\\n         if not cgversions:\\n             raise ValueError(_('no common changegroup version'))\\n         version = max(cgversions)\\n \\n     outgoing = _computeoutgoing(repo, heads, common)\\n     if not outgoing.missing:\\n         return\\n \\n     if kwargs.get(r'narrow', False):\\n         include = sorted(filter(bool, kwargs.get(r'includepats', [])))\\n         exclude = sorted(filter(bool, kwargs.get(r'excludepats', [])))\\n         filematcher = narrowspec.match(repo.root, include=include,\\n                                        exclude=exclude)\\n     else:\\n         filematcher = None\\n \\n     cgstream = changegroup.makestream(repo, outgoing, version, source,\\n                                       bundlecaps=bundlecaps,\\n                                       filematcher=filematcher)\\n \\n     part = bundler.newpart('changegroup', data=cgstream)\\n     if cgversions:\\n         part.addparam('version', version)\\n \\n     part.addparam('nbchanges', '%d' % len(outgoing.missing),\\n                   mandatory=False)\\n \\n     if 'treemanifest' in repo.requirements:\\n         part.addparam('treemanifest', '1')\\n \\n     if kwargs.get(r'narrow', False) and (include or exclude):\\n         narrowspecpart = bundler.newpart('narrow:spec')\\n         if include:\\n             narrowspecpart.addparam(\\n                 'include', '\\\\n'.join(include), mandatory=True)\\n         if exclude:\\n             narrowspecpart.addparam(\\n                 'exclude', '\\\\n'.join(exclude), mandatory=True)\\n \\n @getbundle2partsgenerator('bookmarks')\\n def _getbundlebookmarkpart(bundler, repo, source, bundlecaps=None,\\n                               b2caps=None, **kwargs):\\n     \\\"\\\"\\\"add a bookmark part to the requested bundle\\\"\\\"\\\"\\n     if not kwargs.get(r'bookmarks', False):\\n         return\\n     if 'bookmarks' not in b2caps:\\n         raise ValueError(_('no common bookmarks exchange method'))\\n     books  = bookmod.listbinbookmarks(repo)\\n     data = bookmod.binaryencode(books)\\n     if data:\\n         bundler.newpart('bookmarks', data=data)\\n \\n @getbundle2partsgenerator('listkeys')\\n def _getbundlelistkeysparts(bundler, repo, source, bundlecaps=None,\\n                             b2caps=None, **kwargs):\\n     \\\"\\\"\\\"add parts containing listkeys namespaces to the requested bundle\\\"\\\"\\\"\\n     listkeys = kwargs.get(r'listkeys', ())\\n     for namespace in listkeys:\\n         part = bundler.newpart('listkeys')\\n         part.addparam('namespace', namespace)\\n         keys = repo.listkeys(namespace).items()\\n         part.data = pushkey.encodekeys(keys)\\n \\n @getbundle2partsgenerator('obsmarkers')\\n def _getbundleobsmarkerpart(bundler, repo, source, bundlecaps=None,\\n                             b2caps=None, heads=None, **kwargs):\\n     \\\"\\\"\\\"add an obsolescence markers part to the requested bundle\\\"\\\"\\\"\\n     if kwargs.get(r'obsmarkers', False):\\n         if heads is None:\\n             heads = repo.heads()\\n         subset = [c.node() for c in repo.set('::%ln', heads)]\\n         markers = repo.obsstore.relevantmarkers(subset)\\n         markers = sorted(markers)\\n         bundle2.buildobsmarkerspart(bundler, markers)\\n \\n @getbundle2partsgenerator('phases')\\n def _getbundlephasespart(bundler, repo, source, bundlecaps=None,\\n                             b2caps=None, heads=None, **kwargs):\\n     \\\"\\\"\\\"add phase heads part to the requested bundle\\\"\\\"\\\"\\n     if kwargs.get(r'phases', False):\\n         if not 'heads' in b2caps.get('phases'):\\n             raise ValueError(_('no common phases exchange method'))\\n         if heads is None:\\n             heads = repo.heads()\\n \\n         headsbyphase = collections.defaultdict(set)\\n         if repo.publishing():\\n             headsbyphase[phases.public] = heads\\n         else:\\n             # find the appropriate heads to move\\n \\n             phase = repo._phasecache.phase\\n             node = repo.changelog.node\\n             rev = repo.changelog.rev\\n             for h in heads:\\n                 headsbyphase[phase(repo, rev(h))].add(h)\\n             seenphases = list(headsbyphase.keys())\\n \\n             # We do not handle anything but public and draft phase for now)\\n             if seenphases:\\n                 assert max(seenphases) \\u003c= phases.draft\\n \\n             # if client is pulling non-public changesets, we need to find\\n             # intermediate public heads.\\n             draftheads = headsbyphase.get(phases.draft, set())\\n             if draftheads:\\n                 publicheads = headsbyphase.get(phases.public, set())\\n \\n                 revset = 'heads(only(%ln, %ln) and public())'\\n                 extraheads = repo.revs(revset, draftheads, publicheads)\\n                 for r in extraheads:\\n                     headsbyphase[phases.public].add(node(r))\\n \\n         # transform data in a format used by the encoding function\\n         phasemapping = []\\n         for phase in phases.allphases:\\n             phasemapping.append(sorted(headsbyphase[phase]))\\n \\n         # generate the actual part\\n         phasedata = phases.binaryencode(phasemapping)\\n         bundler.newpart('phase-heads', data=phasedata)\\n \\n @getbundle2partsgenerator('hgtagsfnodes')\\n def _getbundletagsfnodes(bundler, repo, source, bundlecaps=None,\\n                          b2caps=None, heads=None, common=None,\\n                          **kwargs):\\n     \\\"\\\"\\\"Transfer the .hgtags filenodes mapping.\\n \\n     Only values for heads in this bundle will be transferred.\\n \\n     The part data consists of pairs of 20 byte changeset node and .hgtags\\n     filenodes raw values.\\n     \\\"\\\"\\\"\\n     # Don't send unless:\\n     # - changeset are being exchanged,\\n     # - the client supports it.\\n     if not (kwargs.get(r'cg', True) and 'hgtagsfnodes' in b2caps):\\n         return\\n \\n     outgoing = _computeoutgoing(repo, heads, common)\\n     bundle2.addparttagsfnodescache(repo, bundler, outgoing)\\n \\n @getbundle2partsgenerator('cache:rev-branch-cache')\\n def _getbundlerevbranchcache(bundler, repo, source, bundlecaps=None,\\n                              b2caps=None, heads=None, common=None,\\n                              **kwargs):\\n     \\\"\\\"\\\"Transfer the rev-branch-cache mapping\\n \\n     The payload is a series of data related to each branch\\n \\n     1) branch name length\\n     2) number of open heads\\n     3) number of closed heads\\n     4) open heads nodes\\n     5) closed heads nodes\\n     \\\"\\\"\\\"\\n     # Don't send unless:\\n     # - changeset are being exchanged,\\n     # - the client supports it.\\n     # - narrow bundle isn't in play (not currently compatible).\\n     if (not kwargs.get(r'cg', True)\\n         or 'rev-branch-cache' not in b2caps\\n         or kwargs.get(r'narrow', False)\\n         or repo.ui.has_section(_NARROWACL_SECTION)):\\n         return\\n \\n     outgoing = _computeoutgoing(repo, heads, common)\\n     bundle2.addpartrevbranchcache(repo, bundler, outgoing)\\n \\n def check_heads(repo, their_heads, context):\\n     \\\"\\\"\\\"check if the heads of a repo have been modified\\n \\n     Used by peer for unbundling.\\n     \\\"\\\"\\\"\\n     heads = repo.heads()\\n     heads_hash = hashlib.sha1(''.join(sorted(heads))).digest()\\n     if not (their_heads == ['force'] or their_heads == heads or\\n             their_heads == ['hashed', heads_hash]):\\n         # someone else committed\\/pushed\\/unbundled while we\\n         # were transferring data\\n         raise error.PushRaced('repository changed while %s - '\\n                               'please try again' % context)\\n \\n def unbundle(repo, cg, heads, source, url):\\n     \\\"\\\"\\\"Apply a bundle to a repo.\\n \\n     this function makes sure the repo is locked during the application and have\\n     mechanism to check that no push race occurred between the creation of the\\n     bundle and its application.\\n \\n     If the push was raced as PushRaced exception is raised.\\\"\\\"\\\"\\n     r = 0\\n     # need a transaction when processing a bundle2 stream\\n     # [wlock, lock, tr] - needs to be an array so nested functions can modify it\\n     lockandtr = [None, None, None]\\n     recordout = None\\n     # quick fix for output mismatch with bundle2 in 3.4\\n     captureoutput = repo.ui.configbool('experimental', 'bundle2-output-capture')\\n     if url.startswith('remote:http:') or url.startswith('remote:https:'):\\n         captureoutput = True\\n     try:\\n         # note: outside bundle1, 'heads' is expected to be empty and this\\n         # 'check_heads' call wil be a no-op\\n         check_heads(repo, heads, 'uploading changes')\\n         # push can proceed\\n         if not isinstance(cg, bundle2.unbundle20):\\n             # legacy case: bundle1 (changegroup 01)\\n             txnname = \\\"\\\\n\\\".join([source, util.hidepassword(url)])\\n             with repo.lock(), repo.transaction(txnname) as tr:\\n                 op = bundle2.applybundle(repo, cg, tr, source, url)\\n                 r = bundle2.combinechangegroupresults(op)\\n         else:\\n             r = None\\n             try:\\n                 def gettransaction():\\n                     if not lockandtr[2]:\\n                         lockandtr[0] = repo.wlock()\\n                         lockandtr[1] = repo.lock()\\n                         lockandtr[2] = repo.transaction(source)\\n                         lockandtr[2].hookargs['source'] = source\\n                         lockandtr[2].hookargs['url'] = url\\n                         lockandtr[2].hookargs['bundle2'] = '1'\\n                     return lockandtr[2]\\n \\n                 # Do greedy locking by default until we're satisfied with lazy\\n                 # locking.\\n                 if not repo.ui.configbool('experimental', 'bundle2lazylocking'):\\n                     gettransaction()\\n \\n                 op = bundle2.bundleoperation(repo, gettransaction,\\n                                              captureoutput=captureoutput,\\n                                              source='push')\\n                 try:\\n                     op = bundle2.processbundle(repo, cg, op=op)\\n                 finally:\\n                     r = op.reply\\n                     if captureoutput and r is not None:\\n                         repo.ui.pushbuffer(error=True, subproc=True)\\n                         def recordout(output):\\n                             r.newpart('output', data=output, mandatory=False)\\n                 if lockandtr[2] is not None:\\n                     lockandtr[2].close()\\n             except BaseException as exc:\\n                 exc.duringunbundle2 = True\\n                 if captureoutput and r is not None:\\n                     parts = exc._bundle2salvagedoutput = r.salvageoutput()\\n                     def recordout(output):\\n                         part = bundle2.bundlepart('output', data=output,\\n                                                   mandatory=False)\\n                         parts.append(part)\\n                 raise\\n     finally:\\n         lockmod.release(lockandtr[2], lockandtr[1], lockandtr[0])\\n         if recordout is not None:\\n             recordout(repo.ui.popbuffer())\\n     return r\\n \\n def _maybeapplyclonebundle(pullop):\\n     \\\"\\\"\\\"Apply a clone bundle from a remote, if possible.\\\"\\\"\\\"\\n \\n     repo = pullop.repo\\n     remote = pullop.remote\\n \\n     if not repo.ui.configbool('ui', 'clonebundles'):\\n         return\\n \\n     # Only run if local repo is empty.\\n     if len(repo):\\n         return\\n \\n     if pullop.heads:\\n         return\\n \\n     if not remote.capable('clonebundles'):\\n         return\\n \\n     with remote.commandexecutor() as e:\\n         res = e.callcommand('clonebundles', {}).result()\\n \\n     # If we call the wire protocol command, that's good enough to record the\\n     # attempt.\\n     pullop.clonebundleattempted = True\\n \\n     entries = parseclonebundlesmanifest(repo, res)\\n     if not entries:\\n         repo.ui.note(_('no clone bundles available on remote; '\\n                        'falling back to regular clone\\\\n'))\\n         return\\n \\n     entries = filterclonebundleentries(\\n         repo, entries, streamclonerequested=pullop.streamclonerequested)\\n \\n     if not entries:\\n         # There is a thundering herd concern here. However, if a server\\n         # operator doesn't advertise bundles appropriate for its clients,\\n         # they deserve what's coming. Furthermore, from a client's\\n         # perspective, no automatic fallback would mean not being able to\\n         # clone!\\n         repo.ui.warn(_('no compatible clone bundles available on server; '\\n                        'falling back to regular clone\\\\n'))\\n         repo.ui.warn(_('(you may want to report this to the server '\\n                        'operator)\\\\n'))\\n         return\\n \\n     entries = sortclonebundleentries(repo.ui, entries)\\n \\n     url = entries[0]['URL']\\n     repo.ui.status(_('applying clone bundle from %s\\\\n') % url)\\n     if trypullbundlefromurl(repo.ui, repo, url):\\n         repo.ui.status(_('finished applying clone bundle\\\\n'))\\n     # Bundle failed.\\n     #\\n     # We abort by default to avoid the thundering herd of\\n     # clients flooding a server that was expecting expensive\\n     # clone load to be offloaded.\\n     elif repo.ui.configbool('ui', 'clonebundlefallback'):\\n         repo.ui.warn(_('falling back to normal clone\\\\n'))\\n     else:\\n         raise error.Abort(_('error applying bundle'),\\n                           hint=_('if this error persists, consider contacting '\\n                                  'the server operator or disable clone '\\n                                  'bundles via '\\n                                  '\\\"--config ui.clonebundles=false\\\"'))\\n \\n def parseclonebundlesmanifest(repo, s):\\n     \\\"\\\"\\\"Parses the raw text of a clone bundles manifest.\\n \\n     Returns a list of dicts. The dicts have a ``URL`` key corresponding\\n     to the URL and other keys are the attributes for the entry.\\n     \\\"\\\"\\\"\\n     m = []\\n     for line in s.splitlines():\\n         fields = line.split()\\n         if not fields:\\n             continue\\n         attrs = {'URL': fields[0]}\\n         for rawattr in fields[1:]:\\n             key, value = rawattr.split('=', 1)\\n             key = urlreq.unquote(key)\\n             value = urlreq.unquote(value)\\n             attrs[key] = value\\n \\n             # Parse BUNDLESPEC into components. This makes client-side\\n             # preferences easier to specify since you can prefer a single\\n             # component of the BUNDLESPEC.\\n             if key == 'BUNDLESPEC':\\n                 try:\\n                     bundlespec = parsebundlespec(repo, value)\\n                     attrs['COMPRESSION'] = bundlespec.compression\\n                     attrs['VERSION'] = bundlespec.version\\n                 except error.InvalidBundleSpecification:\\n                     pass\\n                 except error.UnsupportedBundleSpecification:\\n                     pass\\n \\n         m.append(attrs)\\n \\n     return m\\n \\n def isstreamclonespec(bundlespec):\\n     # Stream clone v1\\n     if (bundlespec.wirecompression == 'UN' and bundlespec.wireversion == 's1'):\\n         return True\\n \\n     # Stream clone v2\\n     if (bundlespec.wirecompression == 'UN' and \\\\\\n         bundlespec.wireversion == '02' and \\\\\\n         bundlespec.contentopts.get('streamv2')):\\n         return True\\n \\n     return False\\n \\n def filterclonebundleentries(repo, entries, streamclonerequested=False):\\n     \\\"\\\"\\\"Remove incompatible clone bundle manifest entries.\\n \\n     Accepts a list of entries parsed with ``parseclonebundlesmanifest``\\n     and returns a new list consisting of only the entries that this client\\n     should be able to apply.\\n \\n     There is no guarantee we'll be able to apply all returned entries because\\n     the metadata we use to filter on may be missing or wrong.\\n     \\\"\\\"\\\"\\n     newentries = []\\n     for entry in entries:\\n         spec = entry.get('BUNDLESPEC')\\n         if spec:\\n             try:\\n                 bundlespec = parsebundlespec(repo, spec, strict=True)\\n \\n                 # If a stream clone was requested, filter out non-streamclone\\n                 # entries.\\n                 if streamclonerequested and not isstreamclonespec(bundlespec):\\n                     repo.ui.debug('filtering %s because not a stream clone\\\\n' %\\n                                   entry['URL'])\\n                     continue\\n \\n             except error.InvalidBundleSpecification as e:\\n                 repo.ui.debug(stringutil.forcebytestr(e) + '\\\\n')\\n                 continue\\n             except error.UnsupportedBundleSpecification as e:\\n                 repo.ui.debug('filtering %s because unsupported bundle '\\n                               'spec: %s\\\\n' % (\\n                                   entry['URL'], stringutil.forcebytestr(e)))\\n                 continue\\n         # If we don't have a spec and requested a stream clone, we don't know\\n         # what the entry is so don't attempt to apply it.\\n         elif streamclonerequested:\\n             repo.ui.debug('filtering %s because cannot determine if a stream '\\n                           'clone bundle\\\\n' % entry['URL'])\\n             continue\\n \\n         if 'REQUIRESNI' in entry and not sslutil.hassni:\\n             repo.ui.debug('filtering %s because SNI not supported\\\\n' %\\n                           entry['URL'])\\n             continue\\n \\n         newentries.append(entry)\\n \\n     return newentries\\n \\n class clonebundleentry(object):\\n     \\\"\\\"\\\"Represents an item in a clone bundles manifest.\\n \\n     This rich class is needed to support sorting since sorted() in Python 3\\n     doesn't support ``cmp`` and our comparison is complex enough that ``key=``\\n     won't work.\\n     \\\"\\\"\\\"\\n \\n     def __init__(self, value, prefers):\\n         self.value = value\\n         self.prefers = prefers\\n \\n     def _cmp(self, other):\\n         for prefkey, prefvalue in self.prefers:\\n             avalue = self.value.get(prefkey)\\n             bvalue = other.value.get(prefkey)\\n \\n             # Special case for b missing attribute and a matches exactly.\\n             if avalue is not None and bvalue is None and avalue == prefvalue:\\n                 return -1\\n \\n             # Special case for a missing attribute and b matches exactly.\\n             if bvalue is not None and avalue is None and bvalue == prefvalue:\\n                 return 1\\n \\n             # We can't compare unless attribute present on both.\\n             if avalue is None or bvalue is None:\\n                 continue\\n \\n             # Same values should fall back to next attribute.\\n             if avalue == bvalue:\\n                 continue\\n \\n             # Exact matches come first.\\n             if avalue == prefvalue:\\n                 return -1\\n             if bvalue == prefvalue:\\n                 return 1\\n \\n             # Fall back to next attribute.\\n             continue\\n \\n         # If we got here we couldn't sort by attributes and prefers. Fall\\n         # back to index order.\\n         return 0\\n \\n     def __lt__(self, other):\\n         return self._cmp(other) \\u003c 0\\n \\n     def __gt__(self, other):\\n         return self._cmp(other) \\u003e 0\\n \\n     def __eq__(self, other):\\n         return self._cmp(other) == 0\\n \\n     def __le__(self, other):\\n         return self._cmp(other) \\u003c= 0\\n \\n     def __ge__(self, other):\\n         return self._cmp(other) \\u003e= 0\\n \\n     def __ne__(self, other):\\n         return self._cmp(other) != 0\\n \\n def sortclonebundleentries(ui, entries):\\n     prefers = ui.configlist('ui', 'clonebundleprefers')\\n     if not prefers:\\n         return list(entries)\\n \\n     prefers = [p.split('=', 1) for p in prefers]\\n \\n     items = sorted(clonebundleentry(v, prefers) for v in entries)\\n     return [i.value for i in items]\\n \\n def trypullbundlefromurl(ui, repo, url):\\n     \\\"\\\"\\\"Attempt to apply a bundle from a URL.\\\"\\\"\\\"\\n     with repo.lock(), repo.transaction('bundleurl') as tr:\\n         try:\\n             fh = urlmod.open(ui, url)\\n             cg = readbundle(ui, fh, 'stream')\\n \\n             if isinstance(cg, streamclone.streamcloneapplier):\\n                 cg.apply(repo)\\n             else:\\n                 bundle2.applybundle(repo, cg, tr, 'clonebundles', url)\\n             return True\\n         except urlerr.httperror as e:\\n             ui.warn(_('HTTP error fetching bundle: %s\\\\n') %\\n                     stringutil.forcebytestr(e))\\n         except urlerr.urlerror as e:\\n             ui.warn(_('error fetching bundle: %s\\\\n') %\\n                     stringutil.forcebytestr(e.reason))\\n \\n         return False\\n\"}]}],\"properties\":[]}},\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "headers": {
                    "content-length": [
                        "59"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ], 
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 4.7.1+861-aa7e312375cf)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ]
                }, 
                "uri": "https://phab.mercurial-scm.org//api/differential.querydiffs", 
                "method": "POST", 
                "body": "ids%5B0%5D=11058&api.token=cli-hahayouwish"
            }
        }, 
        {
            "response": {
                "headers": {
                    "cache-control": [
                        "no-store"
                    ], 
                    "set-cookie": [
                        "phsid=A%2Fsh6hsdu5dzfurm5gsiy2cmi6kqw33cqikoawcqz2; expires=Thu, 14-Sep-2023 04:15:58 GMT; Max-Age=157680000; path=/; domain=phab.mercurial-scm.org; secure; httponly"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "date": [
                        "Sat, 15 Sep 2018 04:15:58 GMT"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":\"diff --git a\\/tests\\/wireprotohelpers.sh b\\/tests\\/wireprotohelpers.sh\\n--- a\\/tests\\/wireprotohelpers.sh\\n+++ b\\/tests\\/wireprotohelpers.sh\\n@@ -56,3 +56,10 @@\\n web.api.http-v2 = true\\n EOF\\n }\\n+\\n+enablehttpv2client() {\\n+  cat \\u003e\\u003e $HGRCPATH \\u003c\\u003c EOF\\n+[experimental]\\n+httppeer.advertise-v2 = true\\n+EOF\\n+}\\ndiff --git a\\/tests\\/test-wireproto-exchangev2.t b\\/tests\\/test-wireproto-exchangev2.t\\nnew file mode 100644\\n--- \\/dev\\/null\\n+++ b\\/tests\\/test-wireproto-exchangev2.t\\n@@ -0,0 +1,53 @@\\n+Tests for wire protocol version 2 exchange.\\n+Tests in this file should be folded into existing tests once protocol\\n+v2 has enough features that it can be enabled via #testcase in existing\\n+tests.\\n+\\n+  $ . $TESTDIR\\/wireprotohelpers.sh\\n+  $ enablehttpv2client\\n+\\n+  $ hg init server-simple\\n+  $ enablehttpv2 server-simple\\n+  $ cd server-simple\\n+  $ cat \\u003e\\u003e .hg\\/hgrc \\u003c\\u003c EOF\\n+  \\u003e [phases]\\n+  \\u003e publish = false\\n+  \\u003e EOF\\n+  $ echo a0 \\u003e a\\n+  $ echo b0 \\u003e b\\n+  $ hg -q commit -A -m 'commit 0'\\n+\\n+  $ echo a1 \\u003e a\\n+  $ hg commit -m 'commit 1'\\n+  $ hg phase --public -r .\\n+  $ echo a2 \\u003e a\\n+  $ hg commit -m 'commit 2'\\n+\\n+  $ hg -q up -r 0\\n+  $ echo b1 \\u003e b\\n+  $ hg -q commit -m 'head 2 commit 1'\\n+  $ echo b2 \\u003e b\\n+  $ hg -q commit -m 'head 2 commit 2'\\n+\\n+  $ hg serve -p $HGPORT -d --pid-file hg.pid -E error.log\\n+  $ cat hg.pid \\u003e $DAEMON_PIDS\\n+\\n+  $ cd ..\\n+\\n+Test basic clone\\n+\\n+  $ hg --debug clone -U http:\\/\\/localhost:$HGPORT client-simple\\n+  using http:\\/\\/localhost:$HGPORT\\/\\n+  sending capabilities command\\n+  query 1; heads\\n+  sending 2 commands\\n+  sending command heads: {}\\n+  sending command known: {\\n+    'nodes': []\\n+  }\\n+  received frame(size=11; request=1; stream=2; streamflags=stream-begin; type=command-response; flags=continuation)\\n+  received frame(size=43; request=1; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=0; request=1; stream=2; streamflags=; type=command-response; flags=eos)\\n+  received frame(size=11; request=3; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=1; request=3; stream=2; streamflags=; type=command-response; flags=continuation)\\n+  received frame(size=0; request=3; stream=2; streamflags=; type=command-response; flags=eos)\\ndiff --git a\\/mercurial\\/httppeer.py b\\/mercurial\\/httppeer.py\\n--- a\\/mercurial\\/httppeer.py\\n+++ b\\/mercurial\\/httppeer.py\\n@@ -802,7 +802,8 @@\\n             return True\\n \\n         # Other concepts.\\n-        if name in ('bundle2',):\\n+        # TODO remove exchangev2 once we have a command implemented.\\n+        if name in ('bundle2', 'exchangev2'):\\n             return True\\n \\n         # Alias command-* to presence of command of that name.\\ndiff --git a\\/mercurial\\/exchangev2.py b\\/mercurial\\/exchangev2.py\\nnew file mode 100644\\n--- \\/dev\\/null\\n+++ b\\/mercurial\\/exchangev2.py\\n@@ -0,0 +1,55 @@\\n+# exchangev2.py - repository exchange for wire protocol version 2\\n+#\\n+# Copyright 2018 Gregory Szorc \\u003cgregory.szorc@gmail.com\\u003e\\n+#\\n+# This software may be used and distributed according to the terms of the\\n+# GNU General Public License version 2 or any later version.\\n+\\n+from __future__ import absolute_import\\n+\\n+from .node import (\\n+    nullid,\\n+)\\n+from . import (\\n+    setdiscovery,\\n+)\\n+\\n+def pull(pullop):\\n+    \\\"\\\"\\\"Pull using wire protocol version 2.\\\"\\\"\\\"\\n+    repo = pullop.repo\\n+    remote = pullop.remote\\n+\\n+    # Figure out what needs to be fetched.\\n+    common, fetch, remoteheads = _pullchangesetdiscovery(\\n+        repo, remote, pullop.heads, abortwhenunrelated=pullop.force)\\n+\\n+def _pullchangesetdiscovery(repo, remote, heads, abortwhenunrelated=True):\\n+    \\\"\\\"\\\"Determine which changesets need to be pulled.\\\"\\\"\\\"\\n+\\n+    if heads:\\n+        knownnode = repo.changelog.hasnode\\n+        if all(knownnode(head) for head in heads):\\n+            return heads, False, heads\\n+\\n+    # TODO wire protocol version 2 is capable of more efficient discovery\\n+    # than setdiscovery. Consider implementing something better.\\n+    common, fetch, remoteheads = setdiscovery.findcommonheads(\\n+        repo.ui, repo, remote, abortwhenunrelated=abortwhenunrelated)\\n+\\n+    common = set(common)\\n+    remoteheads = set(remoteheads)\\n+\\n+    # If a remote head is filtered locally, put it back in the common set.\\n+    # See the comment in exchange._pulldiscoverychangegroup() for more.\\n+\\n+    if fetch and remoteheads:\\n+        nodemap = repo.unfiltered().changelog.nodemap\\n+\\n+        common |= {head for head in remoteheads if head in nodemap}\\n+\\n+        if set(remoteheads).issubset(common):\\n+            fetch = []\\n+\\n+    common.discard(nullid)\\n+\\n+    return common, fetch, remoteheads\\ndiff --git a\\/mercurial\\/exchange.py b\\/mercurial\\/exchange.py\\n--- a\\/mercurial\\/exchange.py\\n+++ b\\/mercurial\\/exchange.py\\n@@ -26,6 +26,7 @@\\n     changegroup,\\n     discovery,\\n     error,\\n+    exchangev2,\\n     lock as lockmod,\\n     logexchange,\\n     narrowspec,\\n@@ -1506,17 +1507,21 @@\\n \\n     pullop.trmanager = transactionmanager(repo, 'pull', remote.url())\\n     with repo.wlock(), repo.lock(), pullop.trmanager:\\n-        # This should ideally be in _pullbundle2(). However, it needs to run\\n-        # before discovery to avoid extra work.\\n-        _maybeapplyclonebundle(pullop)\\n-        streamclone.maybeperformlegacystreamclone(pullop)\\n-        _pulldiscovery(pullop)\\n-        if pullop.canusebundle2:\\n-            _fullpullbundle2(repo, pullop)\\n-        _pullchangeset(pullop)\\n-        _pullphase(pullop)\\n-        _pullbookmarks(pullop)\\n-        _pullobsolete(pullop)\\n+        # Use the modern wire protocol, if available.\\n+        if remote.capable('exchangev2'):\\n+            exchangev2.pull(pullop)\\n+        else:\\n+            # This should ideally be in _pullbundle2(). However, it needs to run\\n+            # before discovery to avoid extra work.\\n+            _maybeapplyclonebundle(pullop)\\n+            streamclone.maybeperformlegacystreamclone(pullop)\\n+            _pulldiscovery(pullop)\\n+            if pullop.canusebundle2:\\n+                _fullpullbundle2(repo, pullop)\\n+            _pullchangeset(pullop)\\n+            _pullphase(pullop)\\n+            _pullbookmarks(pullop)\\n+            _pullobsolete(pullop)\\n \\n     # storing remotenames\\n     if repo.ui.configbool('experimental', 'remotenames'):\\n\\n\",\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "headers": {
                    "content-length": [
                        "55"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ], 
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 4.7.1+861-aa7e312375cf)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ]
                }, 
                "uri": "https://phab.mercurial-scm.org//api/differential.getrawdiff", 
                "method": "POST", 
                "body": "diffID=11058&api.token=cli-hahayouwish"
            }
        }
    ]
}
